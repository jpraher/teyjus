(***************************************************************************)
(* The code in this module is in charge of putting out all the information *)
(* generated by the procedures in codegen after a successful processing    *)
(* of a module into in the required bytecode form into a specified byteode *)
(* file.                                                                   *)
(***************************************************************************)
(***********************************************************************)
(* auxiliary functions used in the module                              *)
(***********************************************************************)
let map func mylist =
  let _ = List.map func mylist in
  ()

let writeKindIndex kind =
  let cat =
    match kind with
      Absyn.LocalKind(_) -> Writeutil.local
    | Absyn.GlobalKind(_) -> Writeutil.global
    | Absyn.PervasiveKind(_) -> Writeutil.pervasive
  in
  Writeutil.writeint1 cat;
  Writeutil.writeint2 (Absyn.getKindIndex kind)

let getConstantMark constCat =
  match constCat with 
	Absyn.GlobalConstant -> Writeutil.global
  | Absyn.LocalConstant  -> Writeutil.local
  | Absyn.PervasiveConstant (_) -> Writeutil.pervasive
  | _ -> Writeutil.hidden (* assumed to be hidden constant *)		
  
let writeConstIndex const =
  Writeutil.writeint1 (getConstantMark (Absyn.getConstantType const));
  Writeutil.writeint2 (Absyn.getConstantIndex const)

(*****************************************************************************)
(*                  WRITING OUT MODULE HEADER INFORMATION                    *)
(*****************************************************************************)
let writeHeader modName codeSize =
  (* <bytecode version number> *)
  Writeutil.writeWord Writeutil.byteCodeVersionNumber;
  (* [module name] *)
  Writeutil.writeString modName;
  (* <code size in bytes> *)
  Writeutil.writeWord codeSize

(****************************************************************************)
(*                     WRITING OUT KIND INFORMATION                         *)
(****************************************************************************)
let writeKindInfo gkinds lkinds = 
  (* global kind: arity, name *)
  let writeGlobalKind kind =
	Writeutil.writeint1 (Absyn.getKindArity kind);
	Writeutil.writeString (Absyn.getKindName kind)
  in
  (* local kind : arity *)
  let writeLocalKind kind =
	Writeutil.writeint1 (Absyn.getKindArity kind)
  in
  
  let writeKindsAux kinds writeKindFunc =
	let Codegen.KindList(kindList, numKinds) = kinds in
	Writeutil.writeint2 numKinds;
	map writeKindFunc kindList 
  in

  writeKindsAux gkinds writeGlobalKind;
  writeKindsAux lkinds writeLocalKind

(*****************************************************************************)
(*                  WRITING OUT TYPE SKELETON INFORMATION                    *)
(*****************************************************************************)
let writeTypeSkels tyskels =
  (* writing out the prefix representation of a type skeleton *) 
  let rec writeType tySkel =
    match tySkel with
      Absyn.ApplicationType(kind, args) ->
	Writeutil.writeint1 Writeutil.typeMarkKind; 
        writeKindIndex kind;
        map writeType args
    | Absyn.ArrowType(lop, rop) ->
		Writeutil.writeint1 Writeutil.typeMarkArrow;
		map writeType [lop ; rop] 
    | _ -> (* type skeleton variable *)
		Writeutil.writeint1 Writeutil.typeMarkSkeletonVar;
		Writeutil.writeint1 (Absyn.getSkeletonVariableIndex tySkel)
  in

  let writeOneTypeSkel tySkel =
    if (Absyn.getSkeletonNew tySkel) then 
	  writeType (Absyn.getSkeletonType tySkel)
    else ()
  in

  let Codegen.TypeSkeletonList(tySkelList, numTySkels) = tyskels in
  Writeutil.writeint2 numTySkels; 
  map writeOneTypeSkel tySkelList 

(*****************************************************************************)
(*                  WRITING OUT LOCAL AND GLOBAL CONSTANTS                   *)
(*****************************************************************************)
let writeFixity fixity =
  match fixity with
    Absyn.Infix      -> Writeutil.writeint1 Writeutil.fixityMarkInfix
  | Absyn.Infixl     -> Writeutil.writeint1 Writeutil.fixityMarkInfixl
  | Absyn.Infixr     -> Writeutil.writeint1 Writeutil.fixityMarkInfixr
  | Absyn.Prefix     -> Writeutil.writeint1 Writeutil.fixityMarkPrefix
  | Absyn.Prefixr    -> Writeutil.writeint1 Writeutil.fixityMarkPrefixr
  | Absyn.Postfix    -> Writeutil.writeint1 Writeutil.fixityMarkPostfix
  | Absyn.Postfixl   -> Writeutil.writeint1 Writeutil.fixityMarkPostfixl
  | Absyn.NoFixity   -> Writeutil.writeint1 Writeutil.fixityMarkNoFixity 

let writeConstInfo gconsts lconsts hconsts =
  (* global constant: fixity, precedence, type env size, name, tyskelind *)
  (* local constant: fixity, precedence, type env size, tyskelind *)
  let writeConst global const =
    writeFixity (Absyn.getConstantFixity const);
    Writeutil.writeint1 (Absyn.getConstantPrec const);
    Writeutil.writeint1 (Absyn.getConstantTypeEnvSize const);
    (if (global) then Writeutil.writeString (Absyn.getConstantName const)
     else ());
    Writeutil.writeint2 (Absyn.getSkeletonIndex 
			   (Absyn.getConstantSkeletonValue const))
  in

  (* hidden constant: tyskelind *)
  let writeHConst const =
    Writeutil.writeint2 (Absyn.getSkeletonIndex 
			   (Absyn.getConstantSkeletonValue const))
  in
  
  let writeConstInfoAux consts writeConstFunc =
    let Codegen.ConstantList(constList, numConsts) = consts in
    Writeutil.writeint2 numConsts;
    map writeConstFunc constList 
  in

  writeConstInfoAux gconsts (writeConst true);
  writeConstInfoAux lconsts (writeConst false);
  writeConstInfoAux hconsts writeHConst

(****************************************************************************)
(*                   WRITING OUT STRING INFORMATION                         *)
(****************************************************************************)
let writeStrings strs =
  let writeOneString str =
    if (Absyn.getStringInfoNew str) then
      Writeutil.writeString (Absyn.getStringInfoString str)
    else ()
  in

  let Codegen.StringList(strInfo, numStrs) = strs in
  Writeutil.writeint2 numStrs;
  map writeOneString strInfo 


(*****************************************************************************)
(*                WRITING OUT IMPLICATION GOAL DEFINITIONS                   *)
(*****************************************************************************)
let writeImpGoalInfo implGoals =
  let writeDef def =
	let Codegen.ImpPredInfo(pred, offset) = def in
	writeConstIndex pred;
	Writeutil.writeWord offset
  in

  let writeImpGoal impGoal = 
	let Codegen.ImpGoalCode(Codegen.PredList(extPreds, numExtPreds), 
							impPredList, numDefs) =  impGoal
	in
	(* [next clause table]*)
	Writeutil.writeint2 numExtPreds;
	map writeConstIndex extPreds; 
	(* <find code function> *)
	Writeutil.writeint1 Writeutil.findCodeFuncMarkHash;
	(* [search table] *)
	Writeutil.writeint2 numDefs;
	map writeDef impPredList
  in 

  let Codegen.ImpGoalList(impGoalList, numImpGoals) = implGoals in
  (* <number of implication goals>*)
  Writeutil.writeint2 numImpGoals;
  (* [implication goal info] *)
  map writeImpGoal impGoalList

(*****************************************************************************)
(*                     WRITING OUT HASH TABLE INFORMATION                    *)
(*****************************************************************************)
let writeHashTabInfo hashTabs =
  let writeHashEntry hashEntry =
	let Codegen.ConstHashTabEntry(constCat, index, codeLoc) = hashEntry in
	Writeutil.writeint1 (getConstantMark constCat);
	Writeutil.writeint2 index;
	Writeutil.writeWord codeLoc
  in

  (* [hash table] *)
  let writeHashTab hashTab =
	let Codegen.ConstHashTab(numEntries, hashChains) = hashTab in
        (* <number of entries>*)
	Writeutil.writeint2 numEntries;
        (* [hash table entries] *)
	map writeHashEntry hashChains
  in
	
  let Codegen.ConstHashTabs(hashTabList, numHashTabs) = hashTabs in
  (* <number of hash tables> *)
  Writeutil.writeint2 numHashTabs;
  (* [hash tables] *)
  map writeHashTab hashTabList	

(****************************************************************************)
(*    WRITING OUT INFORMATION ABOUT PREDICATE DEFINITIONS IN THIS MODULE    *)
(****************************************************************************)
let writeModDefsInfo nonExpDefs expDefs localDefs defs = 
  let writePredTabs predlist =
	let Codegen.PredList(predNames, numPreds) = predlist in
        (* <number of predicates> *)
	Writeutil.writeint2 numPreds;
        (* [constant indexes]*)
	map writeConstIndex predNames
  in

  let writeSearchTabEntry pred =
	writeConstIndex pred;
	Writeutil.writeWord (Absyn.getConstantCodeInfoClausesIndex pred)
  in

  let writeSearchTab defs =
    let Codegen.PredList(predNames, numPreds) = defs in
	Writeutil.writeint2 numPreds;
	map writeSearchTabEntry predNames
  in

  (* [next clause table] *)
  writePredTabs nonExpDefs;
  (* [exportdef predicate table] *)
  writePredTabs expDefs;
  (* [local predicate table] *)
  writePredTabs localDefs;
  (* <find code function> *)
  Writeutil.writeint1 Writeutil.findCodeFuncMarkHash;
  (* [search table] *)
  writeSearchTab defs

(*****************************************************************************)
(*    WRITING OUT RENAMING INFOR FOR IMPORTED OR ACCUMULATED MODULES         *)
(*****************************************************************************)
let writeRenamingInfo renamingList = 

  let writeRenamingInfoOneMod renaming =
	let writeRenamingKinds kinds =
          let writeRenamingKind kind =
	    Writeutil.writeString (Absyn.getKindName kind);
	    writeKindIndex kind
	  in

	  let Codegen.KindList(kindList, numKinds) = kinds in
	  Writeutil.writeint2 numKinds;
	  map writeRenamingKind kindList
	in
	
	let writeRenamingConsts consts =
	  let writeRenamingConst const =
	    Writeutil.writeString (Absyn.getConstantName const);
	    writeConstIndex const;
	  in

	  let Codegen.ConstantList(constList, numConsts) = consts in
	  Writeutil.writeint2 numConsts;
	  map writeRenamingConst constList
	in
	
	let Codegen.RenamingInfo(modName, kinds, consts) = renaming in
        (* <module name>*)
	Writeutil.writeString modName;
        (* [kind renaming functions] *)
	writeRenamingKinds kinds;
        (* [constant renaming functions] *)
	writeRenamingConsts consts
  in

  let modNumber = List.length renamingList in
  (* <number of acc/imp modules>*)
  Writeutil.writeint1 modNumber;
  (* [renaming functions] *)
  map writeRenamingInfoOneMod renamingList 


(***************************************************************************)
(*                    WRITING OUT INSTRUCTIONS                             *)
(***************************************************************************)
let writeInstructions code =
  map Instr.writeInstruction code

(************************************************************************)
(*                        INTERFACE FUNCTION                            *)
(************************************************************************)
let writeByteCode cgModule =
  match cgModule with
    Codegen.Module(modName, gkinds, lkinds, gconsts, lconsts, hconsts, defs, 
				   nonExpDefs, expDefs, localDefs, tySkels, strs, impRenaming,
				   accRenaming, instrs, hashTabs, implGoals) ->
	  let Codegen.Instructions(code, codeSize) = instrs in
      (* [module header] *)
      writeHeader modName codeSize;
      (* [global kinds] *)
      (* [local kinds] *)
      writeKindInfo gkinds lkinds;
      (* [type skeletons] *)
      writeTypeSkels tySkels;
      (* [global constants] *)
      (* [local constants] *)
      (* [hidden constants] *)
      writeConstInfo gconsts lconsts hconsts;
      (* [strings] *)
      writeStrings strs;
      (* [implication goal tables] *)
      writeImpGoalInfo implGoals;
      (* [hash tables] *)
      writeHashTabInfo hashTabs;
      (* [bound variable tables] *)
	  Writeutil.writeint2 0;
      (* [import table] *)
	  writeModDefsInfo nonExpDefs expDefs localDefs defs;
      (* [accumulated modules] *)
	  writeRenamingInfo accRenaming;
      (* [imported modules] *)
	  writeRenamingInfo impRenaming;
      (* [instructions] *)
      writeInstructions code
	   
	   
	   
	   





