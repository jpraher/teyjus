After we combine predicate definitions between accumulated modules, the appropriate entry point into the code may change or become run-time dynamic, so the address operand of any call or execute operand cannot be filled in until after all possible accumulations have been completed, nor can we rule out the possibility that these instructions will need to be replaced with call_name or execute_name instructions.  So we need some procedure to insure that these calls are resolved to the appropriate instructions.

The first thing we do is create a list of the predicate names that will be resolved.  Since definition combinations occur when import points are resolved, the earliest we can resolve a predicate is during the resolution of an import table.  Therefore, with each import point, we store a list of the predicate names it should attempt to resolve.  

We can resolve any predicate that is referenced in the generating module or one of it's accumulated descendants.  A list of these predicates can be created by adding all of the predicates global to the generating module and all predicates local to any module which shares the import table.  We can get a list of predicates global to a module by adding the predicates in the next clause table and a list of all exportdef predicates.  The list of local predicates is included specifically.

We need to be able to decide whether or not a predicate dynamically changes.  We can think of initially assuming that a predicate is static until we find anything that could dynamically change it.  Since anything that occurs in the next clause table of the generating module can be extended by the parent's other import-descendants, we mark it dynamic here as well as in the parent import table, unless this is the top level import table, in which case they are left static.  Anything which is exportdef in the parent module is left static in the current import table and dynamic in the parent import table.  Any local predicates are left static, and we ignore both the next clause table and exportdef predicate table of accumulated modules.  Any predicate extended by an implication goal is dynamic.