        I. INSTRUCTIONS FOR UNIFYING AND CREATING TERMS
       ===============================================

* Occurs-check optimization has not been built in yet.
* It is assumed that eta-expansion is not performed in compilation.

The Get Class of Instructions
=============================

     get_variable_t Xn, Ai
   
     This instruction is for the first occurrence of a temporary variable 
     as a head argument. 
     The arguments of this instruction are the following.
     Xn is the data register that should contain the variable, and Ai is 
     a data register containing (a reference to) the term to which the
     variable should be bound.
     The effect of this instruction remains unchanged from the WAM:
     get the value of register Ai, and store it in the register Xn.


     get_variable_p Yn, Ai

     This instruction is the same as the previous one except that Yn denotes
     the nth cell in the current environment (referred to by E) as opposed
     to a data register.

     
     init_variable Xn, Ym

     This instruction is for setting temporary variable in clauses that 
     are bound to some value already. (Those appear in the head of the 
     antecedents of implications.)
     The arguments of this instruction are the following.
     Xn is the data register that should contain the variable, and Ym is
     the mth cell in the clause environment containing (a reference to)
     the term to which the variable should be initialized. 
     The register Xn is set to (ref(addr)) where addr is the address of the 
     dereferenced value of the mth argument cell in the clause environment 
     (referred to by CE).


     init_variable Yn, Ym

     This instruction is the same as the previous one except that Yn denotes
     the nth cell in the current environment (referred to by E) as opposed
     to a data register.

    
     get_m_constant Ai, c

     This instruction is for a constant without type association appearing in 
     a clause head and not embedded in any higher-order structures (flex app 
     or lambda).  
     The arguments of this instruction are the following.
     Ai is a data register containing (a reference to) the incoming term,
     and c is an index to the run-time constant symbol table.
     The effect of this instruction is to first head normalize the term 
     that Ai dereference to. The next action depends on the result of
     head normalization.
     (a) If Ai dereferences to an unbound variable, then if its universe count
         is smaller than that of c (obtained from symbol table), backtracking
         is initiated.
         Otherwise the variable is updated to a constant cell of form
         (const <c, no_type, uc>) with uc being the universe count associated
         with c in the symbol table. The binding is trailed if necessary,
         and the flag CHANGED is set to on.
     (b) If Ai points to a flexible non-variable term (possibly under 
         abstractions), a disagreement pair whose first component is the
         content of Ai and whose second component is the current top of heap
         is pushed onto the PDL stack. A cell of form (const <c, no_type, uc>)
         is pushed to the top of heap with uc being the universe count 
         associated with c in the symbol table. The top of heap register H
         is moved to (H+atomic_size). 
     (c) Otherwise Ai is a rigid term (possibly under abstractions). We assume
         that the decomposition of this term is given by the registers NUMABS,
         NUMARGS, HEAD and ARGVEC set in head normalization. 
         If the cell referred to by HEAD is not of form (const <c, no_type, uc>)
         with uc being the universe count associated with c in the symbol table,
         backtrack occurs. Otherwise, if NUMABS is 0, a checking on NUMARGS is 
         made. If NUMARGS is 0, then execution proceeds. Otherwise, backtrack
         occurs. In the situation where NUMABS is not 0, a checking on 
         whether NUMABS is the same as NUMARGS is made. If they are not equal,
         backtrack occurs. Otherwise, a disagreement pair whose first component
         is the content of Ai and whose second component is the current top of
         heap is pushed onto the PDL stack. A cell of form 
         (const <c, no_type, uc>) is pushed to the top of heap with uc being 
         the universe count associated with c in the symbol table. The top of 
         heap register H is moved to (H+atomic_size). 
     

     get_p_constant Ai, c, L

     This instruction is for a type associated constant appearing in a clause 
     head and not embedded in any higher-order structures (flex app or lambda).
     The arguments of this instruction are the following.
     Ai is a data register containing (a reference to) the incoming term,
     c is an index to the run-time constant symbol table for the constant and
     L is a label to the instructions following those for setting the type
     environment of the constant.

     The effect of this instruction is to first head normalize the term 
     that Ai dereference to. The next action depends on the result of
     head normalization.
     (a) If Ai dereferences to an unbound variable, then if its universe count
         is smaller than that of c (obtained from symbol table), backtracking
         is initiated.
         Otherwise the variable is updated to a reference to the current heap
         top. A constant cell of form 
         (const <c, type, uc, (H+type_const_size)>) is pushed on the heap
         with uc being the universe count associated with c in the symbol table.
         The heap top register H is moved to (H+type_const_size).
         The binding is trailed if necessary. The flag CHANGED is set to on, and
         execution proceeds with type write mode.
     (b) If Ai points to a flexible non-variable term (possibly under 
         abstractions), a disagreement pair whose first component is the
         content of Ai and whose second component is the current top of heap
         is pushed onto the PDL stack. A cell of form 
         (const <c, type, uc, (H+type_const_size)>)
         is pushed to the top of heap with uc being the universe count 
         associated with c in the symbol table. 
         The top of heap register H is moved to (H+type_const_size). 
         Execution proceeds with type write mode.
     (c) Otherwise Ai is a rigid term (possibly under abstractions). We assume
         that the decomposition of this term is given by the registers NUMABS,
         NUMARGS, HEAD and ARGVEC set in head normalization. If the cell 
         referred to by HEAD is not of form (const <c, type, uc, tenv>)
         with uc being the universe count associated with c in the symbol table,
         backtrack occurs. Otherwise, if NUMABS is 0, a checking on NUMARGS is 
         made. If NUMARGS is 0, then execution proceeds with instruction at
         L. Otherwise, backtrack occurs. In the situation where NUMABS 
         is not 0, a checking on whether NUMABS is the same as NUMARGS is made.
         If they are not equal, backtrack occurs. Otherwise, a disagreement pair
         whose first component is the content of Ai and whose second component 
         is the current top of heap is pushed onto the PDL stack. A cell of form
         (const <c, type, uc, (H+type_const_size)>)
         is pushed to the top of heap with uc being the universe count 
         associated with c in the symbol table. The top of heap register H
         is moved to (H+type_const_size). Execution proceeds with type write
         mode.


     get_nil Ai

     * Note that a) type is no longer associated with nil
                 b) the target type of nil is not a type variable
                 c) the term nil is already in eta-long form

     This instruction is for a list nil appearing in a clause head and not
     embedded in any higher-order structures (flex app or abstraction).
     The argument Ai is a data register containing (a reference to) the 
     incoming term.

     The effect of this instruction is first head normalize the term 
     that Ai dereference to. The next action depends on the result of
     head normalization. 
     If Ai dereference to a unbound variable,
     the variable is set to (nil). The binding is trailed if needed, and 
     the flag CHANGED is set to on.
     Otherwise if Ai is a reference to a (non-abstraction) flexible 
     application (indicated by the register RIGFLAG), a disagreement pair
     whose first component points to the term pointed to by Ai and whose 
     second component is the current heap top (H) is pushed onto the heap.
     A cell of form (nil) is created on the heap top, and H is moved
     to (H+atomic_size). 
     Otherwise Ai is a reference to a (non-abstraction) rigid term. 
     If the term is of form (nil), then execution proceeds. Otherwise backtrack
     is initiated.


     get_integer Ai, i
   
     This instruction is for an integer value appearing in a clause head and not
     embedded in any higher-order structures (flex app or abstraction).
     The arguments of this instruction are the following.
     Ai is a data register containing (a reference to) the incoming term, and
     i is the integer value (in C encoding).

     The effect of this instruction is first head normalize the term that
     Ai dereference to. The next action depends on the result of
     head normalization. 
     If Ai dereference to a unbound variable, the variable is bound to (int<i>).
     The binding is trailed if needed, and the flag CHANGED is set to on.
     Otherwise if Ai is a reference to a (non-abstraction) flexible 
     application (indicated by the register RIGFLAG), a disagreement pair
     whose first component points to the term pointed to by Ai and whose 
     second component is the current heap top (H) is pushed onto the heap.
     A cell of form (int<i>) is created on the heap top, and H is moved
     to (H+atomic_size).
     Otherwise Ai is a reference to a (non-abstraction) rigid term. 
     If the term is of form (int<i>), then execution proceeds. 
     Otherwise backtrack is initiated.


     get_float Ai, fl
   
     This instruction is for a float value appearing in a clause head and not
     embedded in any higher-order structures (flex app or abstraction).
     The arguments of this instruction are the following.
     Ai is a data register containing (a reference to) the incoming term and
     fl is the float value (in C encoding).

     The effect of this instruction is first head normalize the term that
     Ai dereference to. The next action depends on the result of
     head normalization. 
     If Ai dereference to a unbound variable, the variable is bound to 
     (float<fl>). The binding is trailed if needed, and the flag CHANGED is 
     set to on.
     Otherwise if Ai is a reference to a (non-abstraction) flexible 
     application (indicated by the register RIGFLAG), a disagreement pair
     whose first component points to the term pointed to by Ai and whose 
     second component is the current heap top (H) is pushed onto the heap.
     A cell of form (float<fl>) is created on the heap top, and H is moved
     to (H+atomic_size).
     Otherwise Ai is a reference to a (non-abstraction) rigid term. 
     If the term is of form (float<fl>), then execution proceeds. 
     Otherwise backtrack is initiated.


     get_string Ai, strp

     This instruction is for a string value appearing in a clause head and not
     embedded in any higher-order structures (flex app or abstraction).
     The arguments of this instruction are the following.
     Ai is a data register containing (a reference to) the incoming term and
     strp is the absolute address to a string in C's encoding.

     The effect of this instruction is first head normalize the term that
     Ai dereference to. The next action depends on the result of
     head normalization. 
     If Ai dereference to a unbound variable, the variable is bound to 
     (str<strp>). The binding is trailed if needed, and the flag CHANGED is 
     set to on.
     Otherwise if Ai is a reference to a (non-abstraction) flexible 
     application (indicated by the register RIGFLAG), a disagreement pair
     whose first component points to the term pointed to by Ai and whose 
     second component is the current heap top (H) is pushed onto the heap.
     A cell of form (str<strp>) is created on the heap top, and H is moved
     to (H+atomic_size). 
     Otherwise Ai is a reference to a (non-abstraction) rigid term. 
     If the term is of form (str<strp1>), and the character lists referred to
     by strp and strp1 have the same length and same characters pairwise,
     then execution proceeds.  Otherwise backtrack is initiated.


     get_m_structure Ai, f, n
    
     This instruction is the first in the compilation of a term of structure
     (f t1 ... tm) where f is a constant without type associations appearing
     as a head argument and not embedded in any higher-order structures 
     (flex app or abstraction).
     The arguments of this instruction are the following. 
     Ai is a data register containing (a reference to) the incoming term, 
     f is an index to the run-time constant symbol table for the functor
     of the structure and n is the arity of this structure.
    
     The effect of this instruction is to first head normalize the term that
     Ai dereference to. The next action depends on the result of head 
     normalization:

     (a) If Ai dereferences to an unbound variable, then if its
         universe count is smaller than that of f (obtained from symbol table), 
         backtracking is initiated. 
         Otherwise, the VAR_BEING_BOUND register is set to point to the top of
         the heap, the ADJ register is set to the universe count associated 
         with the variable, the variable is changed to a reference to the 
         top of the heap, the binding is trailed if necessary and the occur 
         check mode and the flag CHANGED are set on. 
         Then an application object with arity n, function
         component of the form (const <f, no_type, uc>) where uc is the 
         universe count associated with f in the symbol table and arguments 
         pointing to (H+app_head_size) is pushed onto the heap. 
         The S register is set to (H+app_head_size) and H (top of heap) 
         register is moved to (H+app_head_size+(n*atomic_size)) 
         (thereby allocating space for the n arguments). 
         Execution proceeds in write mode.

     (b) If Ai points to a flexible non-variable term (possibly under 
         abstractions), a disagreement pair whose first component is the 
         content of Ai, and whose second component is H is pushed onto the PDL 
         stack. Then an application object with arity n, function
         component of the form (const <f, no_type, uc>) where uc is the 
         universe count associated with f in the symbol table and arguments 
         pointing to (H+app_head_size) is pushed onto the heap. The S register 
         is set to (H+app_head_size) and the H (top of heap) register is moved 
         to (H+app_head_size+n*atomic_size) (thereby allocating space for the 
         n arguments). 
         The ADJ register is set to the value of UC (universe counter).
         Execution proceeds in write mode and with the occurs check mode off. 

     (c) Otherwise Ai points to a rigid term (possibly under abstractions).
         We assume that the decomposition result of this term is given by  
         registers NUMARGS, NUMABS, HEAD and ARGVEC set in head normalization.
         If the term referred to by HEAD is not of form (const<f, no_type, uc>),
         backtrack occurs.
         Otherwise, if NUMABS is 0, a checking on whether n equals to NUMARGS
         is made. If it is the case, the S register is set to the content of 
         ARGVEC, and execution proceeds in read mode. Otherwise, backtrack
         occurs. 
         If NUMABS is not 0, a checking on whether n equals to (NUMARGS+NUMABS)
         is made. If it is not the case, backtrack occurs.
         Otherwise, the application with functor f should be eta-expanded.
         Then a disagreement pair whose first component is the content of Ai,
         and whose second component is H is pushed onto the PDL stack.
         An application object with arity n, function component of the form
         (const <f, no_type, uc>) where uc is the universe count associated
         with f in the symbol table and arguments pointing to (H+app_head_size) 
         is pushed onto the heap.
         The S register is set to (H+app_head_size) and the H (top of heap) 
         register is moved to (H+app_head_size+n*atomic_size) 
         (thereby allocating space for the n arguments). 
         The ADJ register is set to the value of UC (universe counter).
         Execution proceeds in write mode and with the occurs check mode off. 
 

     get_p_structure Ai, f, n
     
     This instruction is the first in the compilation of a term of structure
     (f t1 ... tm) where f is a constant with type associations appearing
     as a head argument and not embedded in any higher-order structures 
     (flex app or abstraction).       
     The arguments of this instruction are the following.
     Ai is a data register containing (a reference to) the incoming term,
     f is an index to the run-time constant symbol table for the functor
     of the structure and n is the arity of the structure

     The effect of this instruction is to first head normalize the term that
     Ai dereference to. The next action depends on the result of head 
     normalization:
     (a) If Ai now dereferences to an unbound variable and its universe
         count is less than that of f (obtained from the symbol table), 
         backtracking is initiated. Otherwise the VAR_BEING_BOUND register 
         is set to point to the top of heap, the ADJ register is set to the 
         universe count of the variable, the variable is changed to a reference 
         to the top of the heap, the binding is trailed if needed and the 
         occurs check mode and the CHANGED flag are set on. 
         Then an application object with arity n, function 
         component a reference to (H+app_head_size+n*atomic_size) and 
         arguments pointer to (H+app_head_size) is pushed onto the
         heap. The S register is set to (H+app_head_size) and the H 
         (top of heap) register is moved to (H+app_head_size+n*atomic_size) 
         (thereby allocating space for the n arguments). 
         A constant cell of the form (const <f, type, uc, H+type_const_size>) 
         is pushed onto the heap with uc being the universe count associated 
         with f (obtained from the symbol table). H is moved to 
         (H+type_const_size) and execution proceeds in write and type write 
         modes. 
     (b) If Ai points to a flexible non-variable term (possibly under 
         abstractions), a disagreement pair whose first component is the 
         contents of Ai and whose second component is H is pushed onto the 
         PDL stack. Then an application object with arity n, function component
         a reference to (H+app_head_size+n*atomic_size) and arguments pointer to
         (H+app_head_size) is pushed onto the heap. The S register is set to 
         (H+app_head_size) and the H (top of heap) register is moved to 
         (H+app_head_size+n*atomic_size) (thereby allocating space for the n
         arguments). A constant cell of the form 
         (const <f, type, uc, H+type_const_size>) is pushed
         onto the heap with uc being the universe count associated with f
         (obtained from the symbol table) and  H is moved to 
         (H+type_const_size). The ADJ register is set to the value of 
         UC (universe counter) and execution proceeds in write and type write 
         modes and with occurs check mode off. 
     (c) Otherwise Ai points to a rigid term (possibly under abstractions).
         We assume that the decomposition result of this term is given by  
         registers NUMARGS, NUMABS, HEAD and ARGVEC set in head normalization.
         If the term referred by HEAD is not of form 
         (const <f, type, uc, tenv>), backtrack occurs.
         Otherwise, if NUMABS is 0, a checking on whether n equals to NUMARGS
         is made. If it is the case, the S register is set to the content of 
         ARGVEC, the TS register is set to tenv and execution proceeds in 
         read mode and type read mode. Otherwise, backtrack occurs. 
         If NUMABS is not 0, a checking on whether n equals to (NUMARGS+NUMABS)
         is made. If it is not the case, backtrack occurs.
         Otherwise, the application with functor f should be eta-expanded.
         Then a disagreement pair whose first component is the content of Ai,
         and whose second component is H is pushed onto the PDL stack.
         An application object with arity n, function component a reference
         to (H+app_head_size+n*atomic_size) and arguments pointer to
         (H+app_head_size) is pushed onto the heap.
         The S register is set to (H+app_head_size) and the H (top of heap) 
         register is moved to (H+app_head_size+n*atomic_size) 
         (thereby allocating space for the n arguments). A constant cell
         of form (const <f, type, uc, (H+type_const_size)>) is pushed
         onto the heap with uc being the universe count associated with 
         f (obtained from the symbol table). H is moved to (H+typed_const_size).
         The ADJ register is set to the value of UC (universe counter).
         Execution proceeds in write mode and type write mode and with the 
         occurs check mode off.  


     get_list Ai
        
     * Note that a) type is no longer associated with cons
                 b) the target type of cons is not a type variable
                 c) the term (cons a1 a2) is already in eta-long form.  

     This instruction is the first in complication of the list structure 
     appearing in a clause head and not embedded in any higher-order 
     structures (flex app or abstraction).
     The argument Ai is a data register containing (a reference to) the
     incoming term.
       
     The effect of this instruction is to first head normalize the term that
     Ai dereference to. The next action depends on the result of head 
     normalization:
     (a) If Ai now dereferences to an unbound variable, the VAR_BEING_BOUND 
         register is set to point to the current heap top, the ADJ register
         is set to the universe count of the variable, the variable is
         changed to a cons cell pointing to the top of the heap, the binding
         is trailed if needed and the occurs check mode is set on. The S
         register is set to the current top of heap (H), the top of heap (H)
         is moved to (H+2*atomic_size), thereby allocating space for the two
         arguments of cons. The flag CHANGED is set on and execution proceeds 
         in write mode.
     (b) If Ai points to a (non-abstraction) flexible application, 
         a disagreement pair whose first component is the 
         content of Ai and whose second component is the top of the heap
         is pushed onto the PDL stack. Then a cons cell pointing to 
         (H+atomic_size) is pushed on the heap. H is moved to (H+2*atomic_size).
         Execution proceeds in write mode with occurs check mode off.
     (c) Otherwise Ai dereference to a non-abstraction rigid term. 
         If CONSFLAG is false, backtracking is initiated. If it is true,
         the S register is set to ARGVEC and execution proceeds in read mode.


The Put Class of Instructions
=============================

   put_variable_t Xn, Ai

   This instruction is for the first occurrence of a temporary variable as a 
   body argument or as the head of a higher-order structure appearing in a 
   clause head.
   The arguments of this instructions are data registers which should refer
   to the variable.
   The registers Xn and Ai are set to the form (ref<H>). A cell of form
   (fv<uc>) is pushed onto the top of heap, where uc is the current value
   of the universe count register UC. Then H is moved to (H+atomic_size).


   put_variable_p Yn, Ai

   This instruction is for the first occurrence of a permanent variable as a 
   body argument or as the head of a higher-order structure appearing in a 
   clause head. 
   Let addr be the address of the nth argument cell in the current environment.
   The register Ai is set to (ref<addr>), and a cell of form (fv<uc>) is
   created at the address addr.


   put_value Xn, Ai

   This instruction is for the subsequent occurrences of a temporary variable 
   as a body argument or as the head of a higher-order structure appearing in 
   a clause head.
   Unchanged from that in the WAM: the register Ai is set to the content of Xn


   put_value Yn, Ai

   This instruction is for the subsequent occurrences of a permanent variable 
   as a body argument or as the head of a higher-order structure appearing in 
   a clause head.
   If the dereference of Yn is a unbound variable or a heap term, Ai is
   set to a reference referring to the dereference result. Otherwise, 
   the dereference of Yn must be a constant without type association 
   (including special ones) or cons, an then it is copied into Ai.

   [Alternative:
    If Yn (nth argument cell in the current environment) is a unbound variable,
    Ai is set to (ref<addr>), where addr is the address of the nth argument
    cell in the current environment. Otherwise, the content of Yn is copied
    to Ai. 
    The latter avoided dereferencing inside this instruction, but may 
    cause unnecessary indirection when accessing Ai.
   ]
   
   put_unsafe_value Yn, Ai

   As in the WAM, this instruction represents the first occurrence of a
   permanent variable in a goal prior to whose invocation it will be
   trimmed and where the variable was not initialized by a get_variable
   or unify_variable instruction.

   Yn is dereferenced. If this cell is a constant without type association,
   cons, nil or special constant including int, float and string,
   then its content is copied to Ai. Otherwise, if the cell resides in
   the current environment (in which case it must be a unbound variable), 
   the value of this cell is copied onto the current top of heap. 
   This cell and Ai are set to a reference to this "heap copy", and the 
   binding is trailed if necessary. 
   Otherwise, the cell resides in some previous environment or on the heap.
   Ai is set to (ref(addr)), where addr is the address of this cell. 
   
   [An alternative:
    A checking on whether the dereference of Yn is a constant without type
    association or cons or nil or special constant may be too expensive
    when it is a unbound variable. This instruction may be changed into
    the following: 
    Yn is dereferenced. If this cell is a constant without type association,
    then its content is copied to Ai. Otherwise, if the cell resides in
    the current environment (now it could be cons/nil/spec const/var),
    a checking is made on whether it is a unbound variable. If it is,
    the value of this cell is copied onto the current heap top and 
    the cell of Ai are set to a reference to this "heap copy", and the
    binding is trailed if necessary. Otherwise, this cell must be
    a cons, nil or a special constant, then it is copied into the register Ai.
    In all other situations, Ai is set to (ref(addr)) where addr is the 
    address of the dereference of Yn.

    Comparing with the former, the disadvantage is that 1) an 
    additional checking is needed in the situation that the dereference of Yn
    is on the current env, 2) if the dereference of Yn is cons, nil or 
    special constants that resides on the heap or previous envs, there is 
    one extra level of indirection when accessing it from Ai. (Ai is set to
    ref as opposed to the term directly in the former method.)  
   ]
 

   copy_value Yn, Ai

   This instruction makes Ai a reference to the dereference of Yn that is
   known to be data residing on heap. This may be needed for 
   making sure that the function part of an app or the body of a lambda
   resides in a register. There is a counterpart to this instruction for
   the situation when Yn may not be a reference to the heap. It is called
   globalize and appears in the set category of instructions.

   [An alternative is to copy the content of Yn to Ai without dereferencing.
    Comparing with the former, the cost for dereferencing is avoided. However,
    if Yn has more than one level of indirection and Ai is used multiple 
    times later, then dereferecing has to start from Yn in all those places,
    as opposed only once in this instruction.
   ]

   put_m_const Ai, c

   The register Ai is set to (const<c, no_type, uc>) where uc is the 
   universe count associated with c that is obtained from the symbol table.

   put_p_const Ai, c

   The cell (const<c, type, uc, (H+type_const_size)>) is pushed onto the 
   current top of heap with uc as the universe count associated with c in
   the symbol table. 
   The register Ai is set to (ref<H>) and H is moved to (H+type_const_size). 

   put_nil Ai

   The register Ai is set to (nil).

  
   put_integer Ai, i

   The register Ai is set to (int<i>). Note i is the value (in C encoding)
   of the integer.


   put_float Ai, fl

   The register Ai is set to (float<fl>). Note fl is the value (in C encoding)
   of the float.


   put_string Ai, strp

   The register Ai is set to (str<strp>). Note strp is a pointer to the 
   string (in C encoding).
   

   put_index Ai, i


   This instruction is for a de Bruijn index appearing in the head of 
   an application or as the body of an abstraction.
   The register Ai is set to a reference to the current heap top, onto which
   the cell (bv<i>) is pushed onto.

   [Note: The instruction set_index i should be used in the situation that
    the de Bruijn index is an argument of a application.
   ]


   put_app Ai, Xj, n

   The content of Xj is first checked. If it is not a reference, it is copied
   onto the top of heap, and Xj is updated to (ref<H>). Then H is incremented
   by atomic_size. 
   Now Xj must contain a reference cell, and suppose its target address is
   addr. The register Ai is set to (ref<H>). An application object with
   arity n, function pointer to addr, and argument pointer to (H+app_head_size)
   is pushed onto the current heap top. The register S is set to 
   (H+app_head_size) and H is moved to (H+app_head_size+n*atomic_size).

   (Note that the argument vector should be remembered by S because type
    associated constants could appear.)


   put_list Ai

   The register Ai is set to (cons<H>). The register S is set to the current
   top of heap (H). H is moved to (H+cons_arg_size).

   
   put_lambda Ai, Xj, n
   
   A checking on whether the content of Xj is a reference is first made.
   If it is not the case, it is copied onto the top of heap, and Xj is 
   updated to (ref<H>). Then H is incremented by atomic_size.
   Now Xj must contain a reference cell, and suppose its target address is
   addr. The register Ai is set to (ref<H>). An abstraction object of form
   (lam(n, addr)) is pushed onto the heap top. Then H is incremented by
   atomic_size.


The Unify Class of Instructions
===============================
   
   unify_variable_t Xi

   This instruction is used in compiling the first occurrence of a temporary
   variable in a clause head that is within a structure but not embedded
   in a higher-order structure (flex app or lambda).
   Write mode:
   The cell referred to by S is updated to (fv<uc>), where uc is the current
   value of the ADJ register. Xi is set to (ref<S>) and then S is moved to
   (S+atomic_size).
   Read mode:
   If the cell referred to by S is of form (fv<uc>), Xi is set to (ref<S>),
   and S is moved to (S+atomic_size). Otherwise, the content of 
   the cell referred to by S is copied into Xi. S is moved to (S+atomic_size).


   unify_variable_p Yi

   The only difference between this instruction and the previous one is
   that Yi denotes the ith argument cell in the current environment (referred to
   by E).


   unify_value Xi

   This instruction results from the compilation of a variable that is
   the argument within a structure and that is bound to some global
   value (such as through a unify_variable instruction).
   Read Mode: 
    An interpretive higher order pattern unification procedure is invoked on 
    the pair of terms referred to or contained by Xi and S.
    Upon successful return of this procedure, S is moved to (S+atomic_size).
   Wrire Mode: 
    If the occurs-check flag (OCCFLAG) is off, then the location referred to 
    by S is changed to the content in Xi, and S is increased by atomic_size.
    Otherwise, a specialized version of the interpretive procedure nested_subst
    (see the sml implementation of higher-order pattern unification) 
    is invoked as (nested_subst_oc(VAR_BEING_BOUND, [], t)), where t is the 
    term referred to (or contained) by the register Xi. 
    There are two points to be noticed with regard to the procedure 
    nested_subst_oc.  First, the unbound variable 
    referred to by VAR_BEING_BOUND register has been partially instantiated,
    and therefore in head normalizing t and its substructures, hnorm_withoc
    has to be used to check for the occurrence of VAR_BEING_BOUND in t.
    Second, the procedure nested_subst_oc is responsible for creating a 
    disagreement pair and adding it to the live list if necessary, and 
    returning a proper partial binding for VAR_BEING_BOUND, in the following
    situations: first, VAR_BEING_BOUND occurs in the structure of t;
    second, any unbound variable with universe count higher than the value
    in the register ADJ and third any constant with universe count higher
    than the value in the register ADJ.
    Upon successful return of this procedure, the location referred to by 
    S will be set to (a reference) to the returned structure, and then S is 
    moved to (S+atomic_size).


    unify_value Yi

    The only difference between this instruction and the previous is that now
    the argument denotes the nth argument cell of the current environment.
   

    unify_local_value Xi

    This instruction is like unify_value except that in write mode it may
    have to globalize the value of Xi.
    In particular, its action is
    similar to unify_value except if Xi dereferences to a cell on the
    stack in write mode. In this case, if Xi dereferences to a variable
    identical to VAR_BEING_BOUND, backtracking is initiated. If it is a
    variable different from VAR_BEING_BOUND, a new unbound variable with
    universe count the smaller of that in ADJ and the universe count on
    the dereferenced result of Xi is pushed onto the heap, the unbound variable
    on the stack is changed to a reference to this variable and the binding is
    trailed if necessary. If Xi dereferences to a constant with universe count
    greater than ADJ, backtracking is initiated. Otherwise the cell is
    copied over to heap. Finally, in all these cases where a new cell has
    been created on the heap, the location pointed to by the S register is
    set to point to this cell and the S register is incremented by atomic_size.
 

    unify_local_value Yi

    The only difference between this instruction and the previous is that now
    the argument denotes the nth argument cell of the current environment.


    unify_m_constant c

    Write mode:
     If the occurs check mode (OCCFLAG) is on, a checking on whether ADJ is 
     less than the universe count of c (obtained from the symbol table) is made.
     If it is the case, backtrack is initiated. Otherwise or when occurs check 
     mode is off, the cell referred to by S is changed to 
     (const <c, no_type, uc>) with uc being the universe count associating with
     c in the symbol table. S is moved to (S+atomic_size). 
    Read mode:
     The term referred to by S is first dereferenced, and then head normalized.
     If the result is a unbound variable, the variable is updated to 
     (const <c, no_type, uc>) with uc being the universe count associating with
     c in the symbol table. The binding is trailed if needed. S is set to
     (S+atomic_size) and the flag CHANGED is set to on.
     If the result is a flexible non-variable term (possibly under 
     abstractions), a disagreement pair whose first component is this term and 
     whose second component is the current heap top is pushed onto the PDL 
     stack. A cell of form (const <c, no_type, uc>) is pushed onto the heap
     with uc being the universe count associating with c in the symbol table.
     S is moved to (S+atomic_size).
     Otherwise, the result is a rigid term (possibly under abstractions),
     if the head of this term is not of form (const <c, no_type, uc>),
     backtrack occurs. Otherwise, a checking on whether NUMABS is 0 is made.
     If it is the case, and NUMARGS is 0, S is moved to (S+atomic_size) and
     S is increased by atomic_size. If NUMABS is 0, but NUMARGS is not, 
     backtrack occurs.
     In the case NUMABS is larger than 0, it is checked against NUMARGS.
     If they are not equal, backtrack occurs. Otherwise, a disagreement pair
     whose first component is a reference to the rigid term, and whose second
     component is the current heap top is pushed onto the PDL stack.
     A cell of form (const<c, no_type, uc>) is pushed onto the heap. H is moved 
     to (H+atomic_size) and S is moved to (S+atomic_size). Execution 
     proceeds.
    


    unify_p_constant c, L

    Write mode: 
    If the occurs check mode (OCCFLAG) is on, a checking on whether ADJ is 
    less than the universe count of c (obtained from the symbol table) is made. 
    If it is the case, backtrack is initiated. Otherwise or when occurs check 
    mode is off, the heap cell referred by S is changed to (ref<H>), where H is 
    the current heap top.  Then the cell of form 
    (const <c, type, uc, (H+type_const_size)>) is pushed onto the
    current heap top, with uc being the universe count associated with c in
    the symbol table. H is moved to (H+type_const_size) and S is moved to
    (S+atomic_size). Execution proceeds (in type write mode).              
    Read mode:
    The term referred to by S is first dereferenced, and then head normalized.
    If the result is a unbound variable, the variable is updated to 
    (ref<H>), where H is the current heap top. Then the cell of form 
    (const <c, type, uc, (H+type_const_size)>) is pushed onto the heap with
    uc being the universe count associated with c in the symbol table.
    The binding is trailed if needed, and CHANGED is set to on.
    H is moved to (H+type_const_size) and S is moved to (S+atomic_size).
    Execution proceeds in type write mode.
    If the result is a flexible non-variable term (possibly under abstractions),
    a disagreement pair whose first component is this term and whose second 
    component is the current heap top is pushed onto the PDL stack. A cell of
    form (const <c, type, uc, (H+type_const_size)>) is pushed onto the heap
    with uc being the universe count associating with c in the symbol table.
    H is moved to (H+type_const_size) and S is moved to (S+atomic_size).
    Execution proceeds in type write mode.
    Otherwise, the result is a rigid term (possibly under abstractions),
    if the head of this term is not of form (const <c, type, uc>),
    backtrack occurs. Otherwise, a checking on whether NUMABS is 0 is made.
    If it is the case, and NUMARGS is 0, S is moved to (S+atomic_size) and
    execution jumps to L. If NUMABS is 0, but NUMARGS is not, backtrack occurs.
    In the case NUMABS is larger than 0, it is checked against NUMARGS.
    If they are not equal, backtrack occurs. Otherwise, a disagreement pair
    whose first component is a reference to the rigid term, and whose second
    component is the current heap top is pushed onto the PDL stack.
    A cell of form (const<c, type, uc, (H+type_const_size)>) is pushed onto
    the heap. H is moved to (H+type_const_size) and S is moved to 
    (S+atomic_size). Execution proceeds in type write mode.

    unify_nil 

    * Note that a) type is not associated with nil
                b) the target type of nil is not a type variable
                c) the term nil is already in eta-long form
  
    Write mode: 
    The cell referred to by S is changed to (nil). S is moved to 
    (S+atomic_size).
    Read mode:
    The term referred to by S is first dereferenced, and then head normalized.
    If the result is a unbound variable, it is changed to (nil). The binding
    is trailed if necessary, and CHANGED is set to on. S is increased by
    atomic_size.
    If the result is a flexible application, then a disagreement pair whose
    first component is a reference to the application and whose second component
    is the current heap top is pushed onto the PDL stack. Then a cell (nil)
    is pushed onto the current heap top. H is moved to (H+atomic_size) and
    S is moved to (S+atomic_size).
    Otherwise, the result is a (non-abstraction) rigid term. If the term is
    (nil), S is increased by atomic_size, and execution proceeds. 
    Otherwise backtrack is initiated.


    unify_integer i

    Note that i is the value of the integer (C encoding).
    Write mode:
    The cell referred to by S is changed to (int<i>). S is moved to 
    (S+atomic_size).   
    Read mode:
    The term referred to by S is first dereferenced, and then head normalized.
    If the result is a unbound variable, it is changed to (int<i>). The binding
    is trailed if necessary, the flag CHANGED is set to on, and S is increased
    by atomic_size.
    If the result is a flexible application, then a disagreement pair whose
    first component is a reference to the application and whose second component
    is the current heap top is pushed onto the PDL stack. Then a cell (int<i>)
    is pushed onto the current heap top. H is moved to (H+atomic_size) and
    S is moved to (S+atomic_size).
    Otherwise, the result is a (non-abstraction) rigid term. If the term is
    (int<i>), S is increased by atomic_size, and execution proceeds. Otherwise 
    backtrack is initiated.

   
    unify_float fl

    Note that fl is the value of the float (C encoding).
    Write mode:
    The cell referred to by S is changed to (float<fl>). S is moved to 
    (S+atomic_size).   
    Read mode:
    The term referred to by S is first dereferenced, and then head normalized.
    If the result is a unbound variable, it is changed to (float<fl>). 
    The binding is trailed if necessary, the flag CHANGED is set to on, and S
    is increased by atomic_size.
    If the result is a flexible application, then a disagreement pair whose
    first component is a reference to the application and whose second component
    is the current heap top is pushed onto the PDL stack. Then a cell 
    (float<fl>) is pushed onto the current heap top. H is moved to 
    (H+atomic_size) and S is moved to (S+atomic_size).
    Otherwise, the result is a (non-abstraction) rigid term. If the term is
    (float<fl>), S is increased by atomic_size, and execution proceeds. 
    Otherwise backtrack is initiated.


    unify_string strp

    Note that strp is a pointer to a string in C encoding.
    Write mode:
    The cell referred to by S is changed to (str<strp>). S is moved to 
    (S+atomic_size).   
    Read mode:
    The term referred to by S is first dereferenced, and then head normalized.
    If the result is a unbound variable, it is changed to (str<strp>). 
    The binding is trailed if necessary, the flag CHANGED is set to on, and S
    is increased by atomic_size.
    If the result is a flexible application, then a disagreement pair whose
    first component is a reference to the application and whose second component
    is the current heap top is pushed onto the PDL stack. Then a cell 
    (str<strp>) is pushed onto the current heap top. H is moved to 
    (H+atomic_size) and S is moved to (S+atomic_size).
    Otherwise, the result is a (non-abstraction) rigid term. If the term is
    (str<strp1>), and the character lists referred by strp and strp1 have the 
    same length and same characters pairwise, S is increased by atomic_size, and
    execution proceeds. Otherwise backtrack is initiated.


    unify_void n

    This instruction is the same as the WAM version. 
    Write mode: create cells (fv<uc>) on the locations from S to 
                (S+(n-1)*atomic_size), where uc is the current value of the ADJ
                register. S is moved to (S+(n-1)*atomic_size).
    Read mode:  S is moved to (S+(n-1)*atomic_size).


The Set Class of Instructions
=============================

   set_variable_t Xi

   This is used for compiling an unbound variable that appears embedded
   within higher-order structure (flex app or lambda)
   in the head of a clause or an unbound variable embedded within a
   structure in the clause body.
   The location referred to by S is updated to (fv<uc>), where uc is the
   current value of the UC register. Xi is set to (ref<S>) and S is then
   increased by atomic_size.


   set_variable_te Xi

   Like set_variable_t Xi except that the universe count of the current
   environment (UCE value) is used instead of the value of UC.


   set_variable_p Yi

   This is used for compiling an unbound permanent variable that appears
   embedded within higher-order structure (flex app or lambda) in the head of a
   clause or an unbound variable embedded within a structure in the
   clause body.
   The instruction is the same as set_variable_t Xi except that 
   Yi denotes the ith argument cell in the current environment as opposed to
   a data register.
   

   set_value_t Xi

   This instruction is used in writing part of an application when the
   component being written is itself an application or something
   similar. In this case, the component would have been written
   previously and a reference to it will be placed in Xn.
   The location referred to by S is set to the content of Xi, and S is increased
   by atomic_size.


   set_value_p Yi

   This instruction is used when it is known that the content of Yi yields
   a reference to the heap. Then S is set to a reference to the dereference
   of Yn, and S is incremented by atomic_size.

   
   globalize_t Xi

   This is used when the dereference of Xi could be something in a register
   or on the stack. 
   If the dereference result of Xi is on heap, then Xi is updated to a reference
   to this result. (May reduce indirection level.)
   Otherwise, this result must have atomic size. Then this result is copied
   to the current top of heap. Xi is set to (ref<H>). Now if the result is
   a variable, it is also updated to (ref<H>), and the binding is trailed if
   necessary. Finally, H is moved to H+atomic_size.

   (Note:
    WAMs *set_local_value Xn* becomes *globalize Xn, set_value Xn*.)

   globalize_pt Yj, Xi

   This is used in place of set_value_p Yj, in the case that Yj could 
   dereference to a stack cell (i.e. was initialized by a get_variable_p or
   put_variable_p instruction). 
   Dereference the term in the jth argument cell of the current environment.
   If the dereference result resides on the stack, (then it must have an atomic
   size), copy it to the top of heap. Xi is set to (ref<H>). Now if the 
   cell is a variable, it is also updated to (ref<H>), and the binding is
   trailed if necessary. H is moved to H+atomic size.
   In the other case, the dereference result must resides on the heap.
   Then Xi is set to a reference to this result.

   (Note: 
    WAMs *set_local_value Yn* becomes *globalize Yn, Xm, set_value Xm*.) 


   set_m_const c

   The location referred to by S is updated to (const<c, no_type, uc>) where
   uc is the universe count associating with c in the symbol table. 
   S is increased by atomic_size.


   set_p_const c 
  
   The location referred to by S is updated to (ref<H>). 
   The cell (const<c, type, uc, (H+type_const_size)>) is pushed onto the
   current top of heap where uc is the universe count associating with c in
   the symbol table. H is moved to (H+type_const_size) and S is increased
   by atomic_size.


   set_nil

   The location referred to by S is updated to (nil), and S is increased by
   atomic_size.


   set_int i

   The location referred to by S is updated to (int<i>), and S is increased by
   atomic_size.


   set_float fl

   The location referred to by S is updated to (float<fl>), and S is increased
   by atomic_size.


   set_string strp

   The location referred to by S is updated to (str<strp>), and S is increased
   by atomic_size.


   set_index i

   The location referred to by S is updated to (bv<i>), and S is increased
   by atomic_size.


   set_lambda n, Xi

   If Xi is not a reference, push its contents onto the heap and make Xi
   a reference to the newly created cell. Now Xi must be a reference and 
   let addr be its address part. Put the value (lam <n, addr>) in the location 
   pointed to by the S register. Increment the S register before proceeding.
   
   [Note that this instruction may be replaced by a use of "put_lambda n, Xi"
    and "set_value Xi". The latter is has the disadvantage of introducing
    an additional level of indirection, but may be easier for the compiler.
   ]

   set_void n
 
   Create cells (fv<uc>) on the locations from S to (S+(n-1)*atomic_size), 
   where uc is the current value of the UC register. 
   S is moved to (S+(n-1)*atomic_size).
 

   deref Xn          

   This is used in preparation for creating a lambda term structure when
   Xn is not known to contain a dereferenced value. Dereference the value
   in Xn and put this back in Xn.

   ** Is this instruction still usful?


       II. INSTRUCTIONS FOR UNIFYING AND CREATING TYPES
       ================================================

A. General Comments
===================

The representation of types is the same as that of first-order terms in the
WAM. Function types are represented in the curried form and get special
treatment similar to that for list cons in the WAM.


B. The Get Class of Instructions
================================

   get_type_variable_t Xn, Ai

   This instruction is used for temporary variables that appear in the type 
   skeleton and association of the predicate constant in the head of a clause. 
   The register Xn is set to the content of Ai.


   get_type_variable_p Yn, Ai

   This instruction is used for permanent variables that appear in the type 
   skeleton and association of the predicate constant in the head of a clause. 
   The nth argument cell in the current environment is set to the content of 
   Ai.


   init_type_variable_t Xn, Ym

   The dereference result (atomic size) of the type in the mth argument cell
   in the environment referred to by CE is copied into Xn.


   init_type_variable_p Yn, Ym

   The dereference result (atomic size) of the type in the mth argument cell
   in the environment referred to by CE is copied into the nth argument cell
   in the current environment (referred to by E).



   get_type_value_t Xn, Ai

   This instruction is used for a temporary variable in the type skeleton and 
   association of the predicate constant in the head of a clause for which a 
   binding might already have been determined.
   An interpretive type unification procedure is invoked on the values of Xn
   and of Ai. (Occurs-check is built in the procedure)



   get_type_value_p Yn, Ai

   The same as the previous one except that Yn denotes the nth argument cell
   in the current environment.

   
   get_type_constant Xi, c

   This instruction is used for a sort in the type association of the 
   predicate constant in the head of a clause that is bound to a constant in 
   this clause.
   The argument c is an index to the run-time kind symbol table.
   The value in Xi is obtained and dereferenced. If the result is of form
   (ty_ref<addr>), then it is changed to (ty_sort<c>). The binding is trailed
   if necessary. Otherwise, if the result is not of form (type_sort<c>),
   backtrack occurs.



   get_type_structure Xi, f

   This instruction is used when a type structure in the type association 
   of the head predicate constant.
   The argument f is an index to the run-time kind symbol table.
   The value in Xi is obtained and dereferenced. If the result is of form
   (ty_ref<addr>), then this cell is updated into (ty_str<H>). This binding
   is trailed if necessary. The register TVAR_BEING_BOUND is set to 
   (ty_str<H>). 
   A cell of form (ty_func<f, n>) is pushed onto the top of heap where n
   is the arity associating with f in the kind table. H is moved to 
   (H+atomic_size), and execution proceeds in type write mode.
   Otherwise, if the result is of form (ty_str<addr>) and the cell at the 
   address addr is of form (func<f, n>), then the register TS is set to
   (addr+atomic_size) and execution proceeds in type read mode. In all
   other cases, backtrack is initiated.

   

   get_type_arrow Xi

   The value in Xi is obtained and dereferenced. If the result is of form
   (ty_ref<addr>), then this cell is updated to (ty_arrow<H>). This binding
   is trailed if necessary. The register TVAR_BEING_BOUND is set to 
   (ty_arrow<H>). Execution proceeds in type write mode.
   Otherwise, if the result is of form (ty_arrow<addr>), the register TS
   is set to addr and execution proceeds in type read mode. In all other
   cases, backtrack is initiated.
  
  
C. The Put Class of Instructions
================================

   put_type_variable_t Xn, Ai


   This instruction is used for transmitting the instantiation of a
   temporary variable appearing in the type skeleton and association
   of the predicate constant of an atomic goal that is the last goal in the 
   clause body.
   A cell of form (ty_ref<H>) is pushed onto the current heap top and copied
   into registers Xn and Ai. H is moved to (H+atomic_size).


   put_type_variable_p Yn, Ai

   This instruction is used for transmitting the instantiation of a
   variable appearing in the type skeleton and association of the predicate 
   constant of an atomic goal when this is an unbound permanent variable.
   A cell of form (ty_ref<addr>) is set into the nth argument cell of the 
   current environment and copied to Ai, where addr is the address of the
   nth argument cell in the current environment. 
   

   put_type_value_t Xn, Ai

   This instruction is used for transmitting the instantiation of a
   variable appearing in the type skeleton and association of the predicate 
   constant of an atomic goal when this value resides in the heap or in a 
   protected stack location. 
   The (derefernce of) content of the register Xn is copied into the register 
   Ai.


   
   put_type_value_p Yn, Ai

   This instruction is used for transmitting the instantiation of a
   variable appearing in the type skeleton and association of the predicate 
   constant of an atomic goal when this value resides in the heap or in a
   protected stack location. 
   The (dereference of) content of the nth argument cell in the current 
   environment is copied into the register Ai.



   put_type_unsafe_value Yn, Ai


   This instruction is the counterpart of put_type_value in a situation
   where the value to be transmitted may well be a reference to a
   location in the current environment and may be lost by trimming.
   If the dereference of the content of the nth argument cell in the current
   environment resides on the current environment and is a unbound type
   variable, then this variable and Ai is updated into (ty_ref<H>). 
   The binding is trailed if necessary. Then (ty_ref<H>) is pushed onto the 
   top of heap and H is moved to (H+atomic_size). Otherwise, the content in 
   the dereferenced cell is copied into Ai.



   put_type_const Ai, c
 

   This instruction is for transmitting a sort in the type association
   of the predicate constant of an atomic goal.
   The argument c is an index to the run-time kind symbol table.
   The register Ai is set to (ty_sort<c>).



   put_type_structure Ai, f


   This instruction is used in the process of transmitting a type structure
   in the type assocation of the predicate constant of an atomic goal.
   The argument f is an index to the run-time kind symbol table.

   The register Ai is set to (ty_str<H>). A cell of form (ty_func<f, n>) 
   is pushed onto the current top of heap where n is the arity associating with
   f in the run-time kind table. Then H is increased by atomic_size.


   put_type_arrow Ai
   
   The register Ai is set to (ty_arrow<H>).


C. The Unify Class of Instructions
==================================

    unify_type_variable_t Xi

    This instruction is used for a variable that appears in a constructed
    type term or in the type environment vector of a constant that is unbound.
    Type read mode: 
    The content in the (atomic) cell referred to by the TS register is
    copied into Xi. TS is increased by atomic_size.
    Type write mode:
    A cell of form (ty_ref<H>) is pushed onto the top of the heap and is copied
    into Xi. Then H is increased by atomic_size.


    unify_type_variable_p Yi

    Same as the previous one except that now Yi should be the ith argument 
    cell in the current environment.


    unify_type_value_t Xi

    This instruction is used for a variable that appears in a type
    structure or in the type environment vector of a constant and that is 
    already bound to some global value.
    Type read mode:
    An interpretive type unification procedure is invoked on the values of Xn
    and of TS. (Occurs-check is built in the procedure) TS is then increased
    by atomic_size.
    Type write mode:
    An interpretive procedure is invoked on the term denoted by Xi to see 
    whether TVAR_BEING_BOUND has an occurrence in it. Note that as opposed to
    a free variable representation, TVAR_BEING_BOUND has already been partially
    instantiated. Upon successful return of this procedure, the (dereference of)
    the content in Xi is copied to the current top of heap, and H
    is then increased by atomic_size.


    unify_type_value_p Yi

    The effect of this instruction is the same as that of the previous one,
    except that Yi denotes the ith argument cell in the current environment.
   

    unify_envty_value_t Xi

    [Note that this instruction is still necessary. For example, let c be 
     a constant of declared type (A -> B) and p be a predicate name of 
     declared type C -> o. For a clause head of form (p (c X)) should be 
     type annotated as: (p [B] (c [A, B] X)), where the second occurrence
     of B should be treated by a unify_envty_value instruction.
    ]

    Type read mode:
    The same as the read branch in unify_type_value_t.
    Type write mode:
    The (deference of) content in Xi is copied to the top of heap, 
    and H is then increased by atomic_size.


    unify_envty_value_p Yi

    The same as the previous one except that now Yi denotes the ith argument 
    cell in the current environment.
    


    unify_type_local_value_t Xi
    
    This instruction is for situations where the variable within a type
    structure is bound to something that is not known to be global.
    The effect is the same as unify_type_value_t except that in type write
    mode if the dereference of Xi is of form (ty_ref<addr>) on the environment 
    stack (addr > E), a cell of form (ty_ref<H>) is pushed onto the top of
    heap. Then the cell on stack and Xi are updated to (ty_ref<H>). The binding
    is trailed if necessary. H is then moved to (H+atomic_size). 
    


    unify_type_local_value_p Yi
 
    The same as the previous one except that Yi denotes the ith argument cell
    in the current environment.



    unify_envty_local_value_t Xi

    This instruction is for situations where the variable in a type
    skeleton of a constant or variable is bound to something that is not
    known to be global. 
    The effect is the same as unify_envty_value_t except that in type write
    mode if the dereference of Xi is a unbound type variable and resides
    on the current environment, a cell of form (ty_ref<H>) is pushed onto the 
    top of heap. Then the cell on stack and Xi are updated to (ty_ref<H>). 
    The binding is trailed if necessary. H is then moved to (H+atomic_size). 
  


    unify_envty_local_value_p Yi

    The same as the previous one except that Yi denotes the ith argument cell
    in the current environment.



    unify_type_constant c
   
    This instruction is used for a sort (type constant) appearing as an
    argument of a type constructor.
    Type read mode:
    If the dereference of TS is of form (ty_ref<addr>), then it is updated into
    (ty_sort<c>). The binding is trailed if necessary. TS is increased by
    atomic_size.
    Otherwise, if the dereference result is of form (ty_sort<c>), execution
    proceeds.
    In all other situations, backtrack is initiated.
    Type write mode:
    A cell of form (ty_sort<c>) is pushed onto the current top of heap, and
    H is increased by atomic_size.


E. The Set Class of Instructions
================================

    set_type_variable_t Xi

    A cell of form (ty_ref<H>) is pushed onto the top of heap and copied into 
    the register Xi. H is increased by atomic_size.



    set_type_variable_p Yi

    The same as the previous one except that Yi denotes the ith argument cell
    in the current environment.


    set_type_value Xi

    The dereference of Xi (atomic size) is copied onto the current top of heap,
    and H is increased by atomic_size.
  

    set_type_value Yi

    The same as the previous one except that Yi denotes the ith argument cell
    in the current environment.


    set_type_local_value Xi

    The effect is the same as set_type_value except that if the dereference
    of Xi is a unbound type variable and resides on the environment stack,
    it is updated to (ty_ref<H>). The cell (ty_ref<H>) is created at the 
    location referred to by H. The binding is trailed if necessary.
    H is then moved to (H+atomic_size). 
    

    set_type_local_value Yi

    The same as the previous one except that Yi denotes the ith argument cell
    in the current environment. 



    set_type_constant c

    A cell of form (ty_sort<c>) is pushed onto the current top of heap,
    and H is then increased by atomic_size.


    

            III. HIGHER-ORDER INSTRUCTIONS
            ==============================

    unify_t Xi, Ai

    This instruction gets the values of the registers Xi and Ai, and
    invokes an interpretive higher-order pattern unification process over them.
    If non-Llambda problems are encountered during this process, they are 
    delayed onto the live list, which is to be examined by
    finish_unify instructions when necessary.


    unify_p Yi, Ai

    The same as the previous instruction except that Yi denotes the ith argument
    cell in the current environment.


    finish_unify 

    First invoke an interpretive higher-order pattern unification procedure
    over the disagreement pairs left on the PDL stack. In this process,
    non-Llambda problems could be delayed onto the global disagreement list.
    When all problems recorded on the PDL stacks are solved, the global
    disagreement list is examined for the occurrence of Llambda problems. 
    If one does occur, it is interpretively solved again.

    Note: "proceed_finish_unify" in the current Teyjus is replaced by 
          "finish_unify" followed by a "proceed". "execute_finish_unify"
          and "call_finish_unify" are removed.


    head_normailze_t Xi

    A head normalization procedure is invoked on the value in Xi. The result 
    is left in Xi.
   

    head_normalize_p Yi

    Same as the previous one except that Yi denotes the ith argument cell of
    the current environment.


               IV. LOGICAL INSTRUCTIONS
               ========================

A. General Comments
===================

(1) The following instructions are for compiling the effects of
quantifiers and implications in goals. Conjunctions are dealt with by
sequencing and disjunctions are compiled by the choice instructions to
be described later.


B. The Instruction Collection
=============================
   

   incr_universe

   This instruction increments the UC register.


   decr_universe
  
   This instruction decrements the UC register.


   set_univ_tag Yi, c

   This instruction compiles a universal quantifier over a variable.
   The ith argument cell in the current environment is updated to (ref<H>).
   A cell of form (const<c, no-type, uc>) is pushed onto
   the top of heap with uc being the value of the UC register. H is then moved
   to (H+atomic_size). 


   tag_exists_t Xi

   This instruction is used in compiling an existential quantifier over a
   variable that appears only in the last goal that is not the consequent of 
   an implication.
   The register Xi is set to (ref<H>). A cell of form (fv<uc>) is pushed onto
   the top of heap with uc being the current value of the UC register.
   H is incremented by atomic_size.


   tag_exists_p Yi

   This instruction is used in compiling an existential quantifier over a
   variable.
   The ith argument cell in the current environment is set to the form 
   (fv<uc>), where uc is the current value of the UC register.


   tag_variable Yi

   This instruction is used for associating a tag with a
   variable whose first occurrence is in the antecedent of an implication
   goal; this initialization is done just prior to invoking the
   implication goal.
   The ith argument cell in the current environment is set to the form
   (fv<uc>), where uc is the value of the UCE field of the current environment. 



   push_impl_point n, t

   This instruction is needed for creating an implication point record
   for an implication that appears in a goal. Here n is the size of the 
   current environment record and t is a pointer to a table that is 
   determined at the compilation time.
   The table has the following information in consecutive locations:
   m : the number of predicates whose definitions could be extended by
       the clauses defined in the antecedent of the implication goal. 
   find_code_func:
       a pointer to the function for finding the address of code for a given 
       predicate defined in the implication point or for determining it is 
       undefined.
   k : the number of predicates that are defined by the clauses in the  
       antecedent of the implication goal.
   link_table: 
       a vector of size m of names (references to the run-time constant symbol 
       table) that possibly extend existing definitions.
   hash/seq search table: 
       a hash or sequence search table should be used to find code of
       the predicates defined in the antecedent of the implication goal.
             
   The instruction determines the top of the stack using n and the registers
   TOS and E: if TOS > E, then TOS points to the current stack top; otherwise,
   there is an environment record, and then the top of stack is (E+n+1).
   Then it allocates a "next clause table" with m entries, and stores E,
   the start address of the hash/seq search table in t, find_code_func,
   I and k in consecutive cells following the next clause table. 
   Next it uses the program context determined by I to initialize the 
   "next clause" (the addr of the next clause, and the implication point record
   in which it resides) of the predicates in the link_table. 
   (This initialization could also be done on demand by inserting the address 
   of a fill_table_entry instruction and supplying this with the newly created
   implication point record address from which can be obtained the vector
   of names for next clauses.) Finally, the I register is updated to
   point to the newly created implication point record and the TOS register
   is updated to the new stack top after allocating the implication point.



   pop_impl_point

   This instruction complements the push_impl_point instruction.
   The I register is set to the value stored in "previous I" field of the 
   current implication point.



   add_imports n, m, L

   This instruction is the first in a sequence of instructions that are
   used for realizing the addition of code in imported modules. The nth
   backchained field of form <counter, most recent choice point> 
   in the import point record pointed to by the CI register is examined. 
   If the choice point value of this cell is
   less recent than B then the backchained field is trailed. 
   Then the backchained field is updated to <counter+1, B>. 
   Finally, if counter is greater than 1, then a jump to the address
   L is executed. Otherwise the top of stack register is set assuming
   that the size of the current environment is m. Specifically, if 
   TOS > E, then TOS is already the top of stack; otherwise, TOS is set
   to (E+m+1).



   push_import t

   This instruction is needed for creating an import point record when a
   clause from a module with imports is used. The assumption is that the
   TOS register knows the current top of stack and hence the designated
   location for the import point record. The argument t is a pointer to a
   compile/load time generated table containing the following fields 
   consecutively.
   n: the number of segments of clauses in this module
   l: the number of locals in this module 
   m: the number of predicates whose previous definition might be extended
      by the code in this module.
   find_code_func:
      a pointer to the head/seq search function to be used to find code
      from the subsequent search table.
   k: the number of predicates defined in this module
   link_table: 
      a vector of size m of names (references to the run-time constant symbol 
      table) that possibly extend existing definitions.
   local constants:
      a vector of size l of locals (references to the run-time constant symbol
      table) of this module. (could be empty)
   hash/seq search table: 
       a hash or sequence search table should be used to find code of
       the predicates defined in this module.

   Using this table an import point record is created on the stack with the 
   following information: 
   (a) a sequence of backchained fields equal to n, each cell initialized 
       to the value <0,B> where B is the current contents of the choice point
       register, 
   (b) a sequence of next clause fields equal to m
   (c) the size of the next clause vector (m)
   (d) the start address of the hash/seq search table
   (e) find_code_func
   (f) the value of the I register
   (g) number of predicates defined in this module (k)
   Then, if the number of local constants for the module is nonzero, the UC 
   register is incremented and the universe level in the symbol table for the 
   local constants is set to the (new) value in the UC register.  
   Next, the program context determined by the I register is used to initialize 
   the vector of next clauses for predicates defined at this implication point 
   and whose definitions might be extensions of previously existing ones. 
   (This initialization could also be done on demand by inserting the address 
    of a fill_table_entry instruction and supplying this with the newly created
    implication point record address from which can be obtained the vector
    of names for next clauses.)  
   Finally, the I register is updated to point to the newly created implication 
   point record, and the TOS register is updated to the new stack top.



   remove_imports n,L

   This instruction manipulates the backchained cell in the course of
   ``removing'' code added due to an import. The nth backchained field of
   form <counter, most recent choice point> in the import point record pointed 
   to by the CI register is examined. If the choice point value of this cell 
   is less recent than B, then the backchained field is trailed.
   The backchained field is then updated into <counter-1, B>.
   If counter is larger than 0, a jump to the instruction at address L
   is executed.



   pop_imports n

   This instruction removes n import point records essentially by
   deleting n items from the chain of implication/import point records
   pointed to by the I register. Notice that in the process the UC
   register must also be decreased if needed for each imported module
   removed.



                V. CONTROL INSTRUCTIONS
                =======================

   allocate n

   This instruction is used to allocate a new environment on the stack,
   needed for a clause that has more than one goal in its body. 
   The top of the stack is determined using the argument m
   in the call instruction previous to the instruction 
   referred to by the CP register, and the registers TOS and E.
   Specifically, if TOS > E, then the current top of stack should be TOS;
   otherwise, the current top of stack should be 
   (E + m permanent variable cells).
   (Note that now TOS no longer refers to the top of stack now, since
    the size of the environment could vary.)
   The current value of E, CP, UC and CI are saved in the following locations 
   and E is set to the new environment record being created on the top of the
   stack. 
   The argument n is one more than the maximum permanent variables
   in the clause. It is used to check for stack overflow errors at the
   point that the environment record is created.



   deallocate 

   Remove the environment frame from the stack. This is achieved simply
   by setting the E and CP registers to the values of the continuation
   environment and continuation (code) point that is stored in the
   environment frame. 


   call n, L

   n: the number of permanent variables to be retained in the continuation 
      environment
   L: address of the predicate being called
   
   This instruction invokes a goal in the clause body after all the
   argument registers are set.
   The CP register is set to the address of the following instruction.
   P is set to L. CE is set to E and B0 is set to B.
   n in this instruction is the number of permanent variables to be retained 
   in the continuation environment. This is accessed as an offset by the
   instructions allocate, and try_me_else.  
  
 

   call_name n, ProcName

   n: the number of permanent variables to be retained in the continuation 
      environment
   ProcName: symbol table reference
  
   This instruction is like call, except that the address for the code to
   be called has to be determined dynamically using a name, given as a
   symbol table pointer ProcName.

   A procedure is invoked for finding the code for ProcName in the program
   context defined by the I register. If such code is found, its address and
   the address of the impl/import record in which that code is found are
   returned by this procedure. The register P is set to the returned code
   address, and the register CI is set to the returned impl/import point
   address. If it is an impl point, then the register CE is set to the 
   corresponding closure environment ("CE" field in that impl point).
   The CP register is set to the instruction following this one. 
   The B0 register is set to B.
   Otherwise, backtracking is initiated.



   execute Proc

   Proc: address of the predicate being called

   This instruction is for calling the last goal in the body of a clause.
   P is set to Proc, and B0 is set to B.


   
   execute_name ProcName

   ProcName: symbol table reference

   This instruction is like execute, except that the address for the code to
   be called has to be determined dynamically using a name, given as a
   symbol table pointer ProcName.

   A procedure is invoked for finding the code for ProcName in the program 
   context defined by the I register. 
   If such code is found, its address and
   the address of the impl/import record in which that code is found are
   returned by this procedure. The register P is set to the returned code
   address, and the register CI is set to the returned impl/import point
   address. If it is an impl point, then the register CE is set to the 
   corresponding closure environment ("CE" field in that impl point).
   The B0 register is set to B.
   Otherwise, backtracking is initiated.


   
   proceed

   This instruction is used at the end of a unit clause. 
   It has the effect of resetting the program pointer P using the value stored
   in the CP register and the CI register using the value stored in the (CIE)
   filed of the environment pointed to by E. If CI refers to an impl point,
   CE is set to the corresponding closure environment ("CE" field in that
   impl point).



               VI. CHOICE INSTRUCTIONS
               =======================


   try_me_else m, L

   This instruction precedes the code for the first clause defining a
   predicate defined by more than one clause and is responsible for
   setting up a choice point record.

   This instruction determines the top of stack by using m, the argument n
   in the call or execute instructions previous to the instruction 
   referred to by the CP register, and the registers TOS and E.
   Specifically, if TOS > E, then the current top of stack should be TOS,
   otherwise, the current top of stack should be 
   (E + n permanent variable cells).
   Then after allocating the choice point record, the new top of stack
   should be the old plus (m + 11) cells, to which the TOS register should
   be set.
   
   The record contains m+11 cells: 
     the first m: argument registers (copy A1 ... Am)
     the current universe count UC
     the current environment E
     the contents of the continuation pointer CE
     the contents of the code context register I
     the contents of the clause implication point register CI
     the previous choice point B
     the cut choice point register B0
     the register LL of the beginning of the live list
     the current trail pointer TR 
     the address of the next clause given by L
     the current heap pointer H
   
   Finally, B is set to point to the newly created choice point and
   HB is set to H. Execution proceeds from the following instruction.



   retry_me_else m, L

   This instruction precedes the code for an intermediate clause in the
   definition of a predicate or the last clause for a predicate whose
   definition in this ``module'' might be an extension of another
   definition. The purpose of this instruction is to reset the state
   using the information stored in the choice point pointed to by the B
   register and to change the next clause field in the choice point to L.
   We assume that the procedure that initiates backtracking would have 
   unwound the trail and set the TR register already.
   This instruction then resets the first m arguments registers (A1...Am)
   and UC, E, LL, CP, I, B0 and H. CE is also reset to the cell
   referred to by the new I. Then HB is set to H, and if CI refers to 
   an impl point, CE is set to corresponding closure environment 
   ("CE" field in that impl point). Then the next clause field in the 
   choice point referred to by B is changed to L. Then execution proceeds
   with the following instruction.


   trust_me m

   This instruction precedes the code for the last clause for a predicate
   whose definition (in this ``module'') cannot be an extension of
   another definition. The purpose of this instruction is to reset the
   state using the information stored in the choice point pointed to by
   the B register and to discard the choice point.  We assume that the
   procedure that initiates backtracking would have unwound the trail and
   set the TR register already. This instruction then resets the first
   m arguments registers (A1...Am)  and UC, E, LL, CP, I, B0 and H. 
   CE is also reset to the cell referred to by the new I. Then HB is set to 
   H, and if CI refers to an impl point, CE is set to corresponding closure
   environment ("CE" field in that impl point). Finally, B is reset to
   the B field in the current choice record referred to by B.



   trust_ext n, Pi

   This instruction is the last in the code for a predicate whose
   definition could be an extension of an existing definition. We assume
   that the unwinding of the trail and the setting of the TR register has
   already been carried out before this instruction is reached.
   Now, if the Pith field in the next clause table is a failing instruction,
   backtracking is invoked. 
   Otherwise the values of the E, CP, UC, I, LL, H, B0 and the first n
   argument registers are reset from the relevant choice point fields and 
   the CI and P registers are reset from the Pith field of the next clause 
   table. 
   Further, the B register is reset to the B value stored in the current 
   choice point and the HB register is reset to the H value in the new choice 
   point. Finally, if the CI register points to an implication point, then 
   the CE register is set to the relevant value in the implication point and
   control is transferred to the program point given by the P register. 



   try m, L

   This instruction precedes the code for the first clause defining a
   predicate defined by more than one clause and is responsible for
   setting up a choice point record.

   This instruction determines the top of stack by using m, the argument n
   in the call or execute instructions previous to the instruction 
   referred to by the CP register, and the registers TOS and E.
   Specifically, if TOS > E, then the current top of stack should be TOS;
   otherwise, the current top of stack should be 
   (E + n permanent variable cells), where n is the argument of the call,
   execute instruction previous to the one currently referred to by CP.
   Then after allocating the choice point record, the new top of stack
   should be the old plus (m + 11) cells, to which the TOS register should
   be set.

   The record contains m+11 cells: 
     the first m: argument registers (copy A1 ... Am)
     the current universe count UC
     the current environment E
     the contents of the continuation pointer CE
     the contents of the code context register I
     the contents of the clause implication point register CI
     the previous choice point B
     the cut choice point register B0
     the register LL for the beginning of the live list
     the current trail pointer TR 
     the address of the following instruction
     the current heap pointer H
   
   Finally, B is set to point to the newly created choice point and
   HB is set to H. Execution proceeds from the instruction at the address L.


   
   retry m, L

   The purpose of this instruction is to reset the state
   using the information stored in the choice point pointed to by the B
   register and to change the next clause field in the choice point to the
   address of the following instruction.
   We assume that the procedure that initiates backtracking would have 
   unwound the trail and set the TR register already.
   This instruction then resets the first m arguments registers (A1...Am)
   and UC, E, LL, CP, I, B0 and H. CE is also reset to the cell
   referred to by the new I. Then HB is set to H, and if CI refers to 
   an impl point, CE is set to corresponding closure environment 
   ("CE" field in that impl point). Then the next clause field in the 
   choice point referred to by B is changed to the address of the following
   instruction, and execution proceeds from the instruction at the address L.



   trust m, L

   This instruction behaves like trust_me with the exception that
   execution eventually continues with the instruction at L.
   We assume that the
   procedure that initiates backtracking would have unwound the trail and
   set the TR register already. This instruction then resets the first
   m arguments registers (A1...Am)  and UC, E, LL, CP, I, B0 and H. 
   CE is also reset to the cell referred to by the new I. Then HB is set to 
   H, and if CI refers to an impl point, CE is set to corresponding closure
   environment ("CE" field in that impl point). B is reset to
   the B field in the current choice record referred to by B. Finally,
   control is transfered to the instruction at L.



   try_else m,L1,L2 

   Same as try_me_else m, L1 except that execution proceeds with the instruction
   at L2.



   retry_else n,L1,L2 

   Same as retry n, L2 except that the next clause field in the current
   choice point is set to L1, and execution proceeds with the instruction
   at L2.


   branch

   (disjunctive goals: TO BE DECIDED)


              VII. INDEXING INSTRUCTIONS
              ==========================

   switch_on_term V,C,L,BV

   Jump to the instruction labelled, respectively V, C, L, or BV,
   depending on whether the (normalized, dereferenced) value of 
   argument register A1 is a flexible term, a rigid term with a constant 
   (integer, float, string, nil, stream) as head, a non-empty list (list cons)
   or a rigid term with a bound variable as its head. 


   switch_on_constant n,tab_addr

   This instruction is encountered when the dereferenced value of the
   register A1 is known to be a rigid term with a constant as its head. 
   In this case, a hash table of size n with starting location tab_addr is
   looked up for a match. If one is found, a branch is executed to the
   instruction address associated with it. If no match is found,
   backtracking is initiated. 


   switch_on_bvar n,tab_addr

   The dereferenced value of register A1 is known to be a rigid term with
   a bound variable as its head. Let the difference between the binder
   length and the bound variable index of the term be m (decided in the
   previous switch_on_term instruction). tab_addr is the address
   of a table of size m pairing natural numbers with code locations. If a
   match is found in tab_addr to m, this yields the address of the next
   instruction.  Otherwise backtracking is initiated. (The argument n is
   the max number that m could take. It is used to compare with m, and 
   if m is larger, then backtracking can be decided immediately without a 
   searching through the branch table.)


   switch_on_reg i,L1,L2

   Look up the ith next clause entry in the implication/import point
   record pointed to by CI. If this happens to be the address of the
   failing procedure, branch to L2. Otherwise branch to L1. 




              VIII. CUT INSTRUCTIONS
              ======================

   neck_cut

   Discard the choice points up to the one pointed to by the B0 register
   by setting the B register to this value and resetting the HB register
   to H field of the choice/branch point record now pointed to by the B
   register. The trail can now be shrunk to reflect the fact that
   bindings between the new HB and top of the heap need not be undone on
   backtracking and similarly between the new B and the top of stack.
   Execution continues with the next instruction.


   get_level Yn

   Set Yn to the current value of the B0 register. Continue execution
   with the next instruction.


   put_level Yn

   Set the B0 register to the value in environment variable Yn. Continue 
   execution with the next instruction. (This instruction is a hack for 
   realizing the right pruning action in interpreted goals with cut.)


   cut Yn

   Discard all the choice points created after that pointed to by Yn by a
   process similar to that carried out with neck_cut, except using Yn
   instead if B0. Continue execution with the next instruction.



            IX. MISCELLANEOUS INSTRUCTIONS
            ==============================

   call_builtin i

   Invoke the ith builtin instruction in the dispatch table.
   The compiler will ensure that argument registers are set up the way needed 
   prior to this instruction. 


   builtin i

   [Set CI to the CIE field of the current environment, if it exist.
    If CI refers to a implication record, set CE to the clause environment field
    stored in the impl record referred to by CI.
    Invoke the ith builtin instruction in the dispatch table.
   ]


   stop

   Exit the simulator, returning to the top level. 


   halt

   Terminate the lambdaProlog session.


   fail

   Go to last backtrack (choice) point.
