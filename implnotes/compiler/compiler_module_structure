Compiler Organization:

Coding standards:
  All tabs are 2 spaces wide.  True tabs are not used.

  Camelcase is used for function and variable names.

  Function definitions should always take the form:
    let functionName arg1 ... argN =
      body

    except when pattern matching a single argument:
    
    let functionName = function
      (pattern) -> ...
    | (pattern) -> ...
  
    (note that some definitions use the less obvious
    let functionName = fun arg1 ... argN = body
    and are being changed.)

  Datatypes:
    All labels of a disjoint union refer at least in part to their type.
    That is, for example

    All datatypes use tuples to represent structured data.  Records
    are never used.  Accessor functions are defined for each datatype
    to access individual fields of the tuple, so that one never matches
    against a tuple to extract a single value.

Module Organization:
  The modules are generally divided into three kinds, those that define
  datatypes and associated functions, those that implement major
  functionality by making use of the aforementioned modules, and finally
  a few utility modules used broadly by all modules.

  Implementation Modules:
  Main:
    This module contains the program entry point (see function "main").
    This module is responsible for parsing command line arguments, and
    then making calls into the Compile module to compile the specified
    module.

    Eventually, a mode will have to be added to parse a single term, using
    functionality defined in the Parse module.

  Compile:
    The compile module manages the compilation process.  The main function
    in the module is "compile".  This function makes calls into the Lpyacc
    module to generate the pre-abstract syntax for both the lambda prolog
    module (.m file) to be compiled, and for the lambda prolog signature
    (.sig file) associated with the module.  It then calls into the
    Translate module to generate the various tables related to the module
    being compiled.  It then calls into the Clauses module to generate the
    abstract syntax for the module, and typecheck the module.  Next, type
    reduction will be applied to the module using module Typereduction.
    Finally, codegeneration will be performed by calling into module Codegen,
    and the output will be written to the specified file.

  Translate:
    The translate module parses various declarations in a module and its
    associated signature, and thereby generates the various symbol tables
    necessary to parse the pre-abstract syntax.

  Parse:
    This module is responsible for parsing and processing both single terms
    (using the exported function "parseTerm") and whole clauses (using the
    exported function "parseClause").

    Parsing a term consists first of parsing the pre-abstract syntax
    representation of a term using a stack of operators and operands in order
    to generate abstract syntax.  Then, of beta-normalizing the abstract
    syntax representation of the term, and finally of fixing the term.

    Parsing a clause consists of parsing the pre-abstract syntax in the same
    manner as when parsing a clause, but then includes the additional steps
    of de-orifying the clauses, and ...

  Lpyacc:
    This module is generated by ocamlyacc from the specification defined
    in Lpyacc.y.  There are two exported functions in this module:
    parseModule, and parseSignature, which handle parsing lambda prolog
    modules and signatures respectively.  The result of each of these
    functions is a pre-abstract syntax module or signature.

  Lplex:
    This module is generated by ocamllex from the specification defined
    in Lplex.l.  It is only used to construct a parser (see module Compile).

  Types:
    This module is responsible for unification of types.  It defines a
    datatype representing lambda prolog types during compilation.  The
    unification function is "unify".  Additionally, a function is defined
    to check whether an application is well-typed, called "checkApply".
    Utility functions to print a type, and to construct a type from a constant
    or kind definition, are also included in this module.

  Datatype Definition Modules:
  Preabsyn:
    This module defines the various types representing the pre-abstract
    syntax of a module.  The types defined represent pre-abstract syntax

  Absyn:
    This module defines the various types representing the abstract syntax
    of a module.  The types defined represent abstract syntax kinds, type
    abreviations, type skeletons, types, constants, terms, goals, definitions,
    clauses, and modules.  It also defines functions operating over these
    types.

  Pervasive:
    This module defines the various pervasive constants and kinds, and creates
    the initial constant and kind symbol tables.  It will eventually make use
    of a generated module (Pervasive_gen) that will define these kinds and
    constants, so that uniformity between the compiler and simulator (which
    both need access to the same information) will be easily achieved.

  Utility Modules:
  Symbol:
    Contains routines for keeping track of symbols.  Encountered symbols are
    given a integer key and stored in a hashmap.

  Table:
    This contains the representation for the various symbol tables.  All of
    these are based on the Map module defined in the ocaml standard library,
    which is based on red-black binary trees.  The module "SymbolTable" within
    this file is table whose key type is a symbol (as defined in the SYMBOL
    module) and whose value is any type.

  Errormsg:
    Routines for recording file positions and printing error messages.  File
    positions contain the name of the file to which the they refer, so that
    positions in multiple files can be safely recorded.
        