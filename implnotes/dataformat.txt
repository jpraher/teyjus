                 INTERNAL ENCODING OF DATA ITEMS
                 ===============================

There are various categories of items that need to be represented on
the heap and (possibly) in machine registers:

   a. terms

   b. types

   c. disagreement pairs

The chosen representation depends on the information that needs to be
retained and on an overall convenience in processing. 

In this new implementation, C structures are adopted for encoding data items.
The present formats are described below by categories.




                      I. REPRESENTATION OF TERMS
                      ==========================

There are actually further sub-category of objects to be represented
here: 

  a. terms 

  b. environment terms

  c. environment lists

Each of these sub-categories is dealt with separately below. 


Representation of terms
=======================

The particular kinds of term items whose representation is considered
in this version are the following:

  a. unbound variables

  b. constants of two kinds --- with and without type associations

  c. bound variables (de Bruijn indices) 

  d. references 

  e. abstractions 

  f. applications 

  g. suspensions 

  h. special categories of constants: integers, floats, nil, cons,
     strings and streams.

A variable number of words is required for different items.
We assume a generic term of atomic size (2 words regardless machine 
architecture), and any item with smaller actual size is enforced to take 
the atomic size. Items that cannot fit in the atomic size are assumed to 
have sizes as integral numbers of words. 


Representation of term category tag
-----------------------------------

The first byte in the leading word of each sort of term is used as its 
category tag belonging to the following set.

enum DF_TermCategory 
{ 
    DF_TM_TAG_VAR,            // existential variables
    DF_TM_TAG_CONST,          // constants 
    DF_TM_TAG_INT,            // integers
    DF_TM_TAG_FLOAT,          // floats
    DF_TM_TAG_NIL,            // empty lists
    DF_TM_TAG_STR,            // strings
    DF_TM_TAG_STREAM,         // streams
    DF_TM_TAG_BVAR,           // lambda bound variables (de Bruijn index)
                              // -- atoms above
    DF_TM_TAG_REF,            // references
                              // -- complex terms below
    DF_TM_TAG_CONS,           // list constructors
    DF_TM_TAG_LAM,            // abstractions
    DF_TM_TAG_APP,            // applications
    DF_TM_TAG_SUSP            // suspensions
};

//term category tag
typedef BYTE DF_TM_TAG;  


Representation of generic term
-------------------------------

//a generic term (head) for every category
typedef struct               
{
    DF_TM_TAG    tag;        /* the common field for every term (head); can 
                                be any one of enum TermCategory.
                                rely on struct alignment */ 
    void         *dummy;     /* a place holder which enforces the size of the 
                                generic term to be 2 words. */
} DF_TERM;

typedef DF_TERM *DF_TERM_PTR; //term pointer



Unbound variables
-----------------
typedef struct
{
    DF_TM_TAG       tag;
    MEM_UNIVIND     univCount;      //unsigned short
} DF_TM_VAR;

We assume the field univCount contains the universe count of the unbound
variable.


De Bruijn indices
-----------------
typedef struct
{
    DF_TM_TAG       tag;
    MEM_EMBEDLEV    index;         //unsigned short
} DF_TM_BV;

We assume the field index contains the value of the de Bruijn index.


Constants    (2 kinds)
---------

1. Constants are partitioned into two sets: one with type associations and the 
   other without. Both sorts have their category tag being DF_TM_TAG_CONST.
   An additional byte is used to indicate whether type is associated with value
   0 or 1.
2. References to constant symbol table are encoded as table index. An 
   alternative method is to use the absolute addresses of corresponding 
   symbol table entries. The reason for using the index approach is discussed 
   in detail in dataformat_comments.txt.
3. Universe count and symbol table index are grouped together, and an alias 
   of integer type is given to this combination. This is used to reduce the cost
   of constant comparison, and details can be found in dataformat_comments.txt.

//name and universe count field for constants
typedef struct {
    MEM_UNIVIND     univCount;      //unsigned short
    MEM_CSTTABIND   symTabIndex;    //unsigned short
} NAMEANDUC;

We assume that the field univCount contains the universe count and 
the field symTabIndex contains the index of this constant to the constant 
symbol table.

//constant without type association
typedef struct { 
    DF_TM_TAG       tag; 
    BOOLEAN         withType;       //unsigned char 
    union {
        unsigned int    value;
        NAMEANDUC       nameAndUC;
    } data;
} DF_TM_CONST;

//constant with type association
typedef struct { 
    DF_TM_TAG       tag; 
    BOOLEAN         withType;        
    union {
        unsigned int    value;
        NAMEANDUC       nameAndUC;
    } data;
    DF_TYPE_PTR     typeEnv;
} DF_TM_TCONST;

We assume that the field withType contains 0 or 1 to indicate whether types
are associated with the constant, and the field typeEnv contains a pointer
to its type environment when types are associated.

Integers
--------
typedef struct
{
    DF_TM_TAG        tag;     
    long int         value;
} DF_TM_INT;


Floats
------
typedef struct       
{
    DF_TM_TAG        tag;     
    float            value;
} DF_TM_FLOAT;


String
------
typedef struct            
{
    DF_TM_TAG        tag;
    char             *charList;
} DF_TM_STR;

Note that we assume the character list is the C encoding of the string.


Stream
------
typedef struct            
{
    DF_TM_TAG        tag;     
    MEM_STREAMTABIND index;   //unsigned short
} DF_TM_STREAM;

We assume the field index contains an index to the stream symbol table.

Nil
---
typedef struct             
{
    DF_TM_TAG        tag;     
} DF_TM_NIL;


Reference
---------
typedef struct             
{
    DF_TM_TAG        tag;     
    DF_TERM_PTR      target;
} DF_TM_REF;


Cons
----
typedef struct             
{
    DF_TM_TAG        tag;     
    DF_TERM_PTR      args;
} DF_TM_CONS;

We assume that the field args contains a pointer to the argument vector with
two entries.

Abstractions
------------
typedef struct             
{
    DF_TM_TAG        tag;     
    MEM_EMBEDLEV     embedLevel;    //unsigned short
    DF_TERM_PTR      body;
} DF_TM_LAM;

We assume that the field embedLevel contains the number of lambdas in the front
of an abstraction, and the field body is a pointer to the abstraction body.


Applications
------------
typedef struct             
{
    DF_TM_TAG        tag;     
    MEM_ARITY        arity;         //unsigned short
    DF_TERM_PTR      functor;
    DF_TERM_PTR      args;
} DF_TM_APP;


We assume that the field arity contains the number of arguments of this 
application, the field functor is a pointer to the function component and 
the field args is a pointer to the argument vector (the number of elements is 
that in the arity field).

An alternative to encode the function component and also the body component
in an abstractions is to use an atomic term instead of a term pointer. 
The pros and cons are discussed in dataformat_comments.txt.


Suspensions
-----------
typedef struct            
{
    DF_TM_TAG         tag;   
    MEM_EMBEDLEV      ol;           //unsigned short
    MEM_EMBEDLEV      nl;           //unsigned short
    DF_TERM_PTR       termSkel;
    DF_ENV_PTR        envList;
} DF_TM_SUSP;

We assume that the fields ol, nl contain the old and new embedding levels,
the field termSkel contains a pointer to the term skeleton and envList
contains a pointer to the environment list of the suspension. 


Representation of environment terms
===================================

There are two kinds of environment terms: dummy terms that essentially
record an embedding level and a pair item that records a term and
an embedding level. 

The representation of environments is folded into that of environment
terms. This is okay since the latter are relevant only as part of some
fixed environment.

At a level of detail, these two sorts of environment items take the forms of:

Dummy environment item
----------------------
typedef struct
{
    BOOLEAN           isDummy;      //unsigned char
    MEM_EMBEDLEV      embedLevel;   //unsigned short
    DF_ENV_PTR        rest;
} DF_ENV_DUMMY;

Pair environment item
typedef struct
{
    BOOLEAN          isDummy;       //unsigned char
    MEM_EMBEDLEV     embedLevel;    //unsigned short
    DF_ENV_PTR       rest;
    DF_TERM_PTR      term;
} DF_ENV_PAIR;

The leading byte is used to denote whether it is a dummy environment item
(0 when it is and 1 otherwise). 
The field embedLevel is assumed to contain the embedding levels, the field
rest is assumed to contain a pointer to the next environment item, and
the field term in a pair environment item is to be a pointer to the term
component.



                      II. REPRESENTATION OF TYPES
                      ===========================


Types are represented on the heap like first-order terms in the WAM. Type
arrows are treated as a special binary operator like list cons in the WAM.
An alternative encoding of type arrows (Boehm tree representation) is 
discussed in dataformat_comments.txt. 

In addition to creating types on the heap, we have to deal with type
skeletons. A similar representation is used for these except that
variables in skeletons are natural numbers. At a level of detail, the variables 
whose instances appear in type environments are represented as their offsets 
in them, whereas the others as "pseudo offsets" greater than the size of type 
environments.
To handle this, one additional kind of cell is included for variables.

The detailed representations are presented below.


Representation of types
=======================

The particular kinds of type items whose representation is considered
in this version are the following:

  a. sorts (constants)

  b. type variables or references

  c. type variables in type skeletons

  d. type structures (constructed types) and type constructors

  e. type arrows


An atomic head of 2 words (regardless machine architecture) is used for
each category of (the heads of) type, and we assume a generic type of this size.

Representation of type category tag
-----------------------------------

The first byte in the leading word of each kind of types is used as its 
category tag belonging to the following set.

//type categories
enum DF_TypeCategory
{
    DF_TY_TAG_SORT,  //sort
    DF_TY_TAG_REF,   //reference
    DF_TY_TAG_SKVAR, //skeleton variable
    DF_TY_TAG_ARROW, //type arrow
    DF_TY_TAG_STR    //type structure
};

//type category tag
typedef BYTE DF_TY_TAG;

Representation of generic type
-------------------------------

//generic type (head) for every category
typedef struct               
{
    DF_TY_TAG       tag;     /* the common field for every type (head); can 
                                be any one of enum TypeCategory.
                                rely on struct alignment */ 
    void            *dummy;  /* a place holder which enforces the size of the 
                                generic term to be 2 words. */
} DF_TYPE;

typedef DF_TYPE *DF_TYPE_PTR; //type pointer


Sorts (constants)
-----------------
typedef struct                        
{
    DF_TY_TAG         tag;
    MEM_KSTTABIND     kindTabIndex;       //unsigned short
} DF_TY_SORT;

We assume that the field kindTabIndex contains the index of this sort to the 
kind symbol table. 

Type variables or references
----------------------------
Only one sort of cell is used for both as in WAM, with the unbound variables
being a reference to itself.

typedef struct                         
{
    DF_TY_TAG         tag;      
    DF_TYPE_PTR       target;
} DF_TY_REF;


Type variables in type skeletons
--------------------------------
typedef struct                         
{
    DF_TY_TAG         tag;
    MEM_SKELIND       offset;             //unsigned short
} DF_TY_SKVAR;

We assume that the offset in the type environment or a pseudo offset of the 
variable is contained in the field offset.

Type structures (constructed types) and type constructors
---------------------------------------------------------

type constructors:

typedef struct                         
{
    MEM_TY_ARITY       arity;
    MEM_KSTTABIND      kindTabIndex;      //unsigned short
} DF_TY_FUNC;

We assume that the field arity contains the arity of this type constructor
and the field kindTabIndex contains the index of this type constructor in
the kind symbol table.
Note that no category tags are associated with type constructors because the
accessing of them must be initiated by that of type structure cells.

typedef struct                         
{
    DF_TY_TAG         tag;       
    DF_TY_FUNC        *funcAndArgs;
} DF_TY_STR;

We assume the funcAndArgs field is a pointer to the functor followed by the 
arguments in contiguous locations.

Type arrows
-----------
typedef struct                         
{
    DF_TY_TAG         tag;       
    DF_TYPE_PTR       args;
} DF_TY_ARROW;

We assume that the field args contains a pointer to the two arguments in
contiguous locations.


               III. DISAGREEMENT PAIRS
               =======================